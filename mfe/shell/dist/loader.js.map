{
  "version": 3,
  "sources": ["../node_modules/src/lib/native-federation.error.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/dom/dom.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/remote-entry/remote-info.handler.ts", "../node_modules/src/lib/remote-entry/shared-info.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/lib/cache/index.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/plugins/storage/session-cache.ts", "../node_modules/src/plugins/storage/localstorage-cache.ts", "../src/loader.js"],
  "sourcesContent": ["class NativeFederationError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NativeFederationError}", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type CacheEntry, type NativeFederationProps, type CacheOf } from \"./cache.contract\";\nimport { toCache } from \"./cache.handler\";\n\ntype GlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as GlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as GlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as GlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): CacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nconst createGlobalCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, globalCacheEntry)\n}\n\nexport {globalCacheEntry, createGlobalCache};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\ntype DomHandler = {\n    createImportMap: (map: ImportMap) => ImportMap,\n    importModule: (url: string) => Promise<any>\n}\n\nconst domHandlerFactory = (): DomHandler => {\n\n    const createImportMap = (map: ImportMap): ImportMap => {\n        document.head.appendChild(\n            Object.assign(document.createElement('script'), {\n                type: 'importmap-shim',\n                innerHTML: JSON.stringify(map),\n            })\n        );\n        return map;\n    }\n\n    const importModule = async <T = any>(url: string): Promise<T> => {\n        return (globalThis as any).importShim(url);\n    }\n\n    return {createImportMap, importModule};\n}\n\nexport {domHandlerFactory, DomHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { ImportMap } from \"./import-map.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { SharedInfoHandler } from \"../remote-entry/shared-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype ImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n    createEmpty: () => ImportMap,\n    merge: (maps: ImportMap[]) => ImportMap\n}\n\nconst importMapHandlerFactory = (sharedInfoHandler: SharedInfoHandler): ImportMapHandler => {\n    \n    const createEmpty = (): ImportMap => ({\n        imports: {},\n        scopes: {}\n    })\n\n    const merge = (maps: ImportMap[]) => {\n        return maps.reduce(\n            (acc: ImportMap, map: ImportMap) => ({\n                imports: { ...acc.imports, ...map.imports },\n                scopes: { ...acc.scopes, ...map.scopes },\n            }),\n            createEmpty()\n        );\n    }\n\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: sharedInfoHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap, createEmpty, merge};\n}\n\nexport {importMapHandlerFactory, ImportMapHandler};", "import type { RemoteInfo } from \"./remote-info.contract\";\nimport type { SharedInfoHandler } from \"./shared-info.handler\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (cacheHandler: CacheHandler<NativeFederationCache>, dependencyHandler: SharedInfoHandler): RemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteInfo)\n            .then(cfg => ({...cfg, baseUrl: _path.getDir(entryUrl)}))\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(\"Must provide valid remoteEntry or remoteName\");\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) return Promise.resolve(cachedRemote);\n        if(!remoteEntryUrl) return Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`);\n\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, RemoteInfoHandler};", "import type { SharedInfo, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationProps, CacheEntry } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedInfo): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype SharedInfoHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst sharedInfoHandlerFactory = (cache: CacheHandler<{\"externals\": CacheEntry<Record<string, string>>}>): SharedInfoHandler => {\n    const getSharedDepRef = (dep: SharedInfo): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, sharedInfoHandlerFactory, SharedInfoHandler};", "import type { CacheExtension, NativeFederationCache } from \"./cache/cache.contract\";\nimport  { cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { DEFAULT_CACHE } from \"./cache/default-cache\";\nimport { domHandlerFactory } from \"./dom/dom.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { remoteInfoHandlerFactory } from \"./remote-entry/remote-info.handler\";\nimport { sharedInfoHandlerFactory } from \"./remote-entry/shared-info.handler\";\n\ntype Config<TCache extends NativeFederationCache = NativeFederationCache> = {\n    cache: TCache\n}\n\nconst defaultConfig = (o: Partial<Config<NativeFederationCache & CacheExtension>>): Config<NativeFederationCache & CacheExtension> => {\n    return {\n        cache: o.cache ?? DEFAULT_CACHE\n    }\n}\n\nconst resolver = <TCache extends NativeFederationCache & CacheExtension>(\n    {cache}: Config<TCache>\n) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    const sharedInfoHandler = sharedInfoHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, sharedInfoHandler);\n    const importMapHandler = importMapHandlerFactory(sharedInfoHandler);\n    const domHandler = domHandlerFactory()\n    return {cacheHandler, sharedInfoHandler, remoteInfoHandler, importMapHandler, domHandler};\n}\n\nexport {resolver, Config, defaultConfig};", "\nimport type { DomHandler } from \"./dom/dom.handler\";\nimport { NativeFederationError } from \"./native-federation.error\";\nimport type { RemoteInfo } from \"./remote-entry/remote-info.contract\";\nimport type { RemoteInfoHandler } from \"./remote-entry/remote-info.handler\";\nimport { defaultConfig, resolver, type Config } from \"./resolver\";\nimport * as _path from \"./utils/path\";\n\ntype RemoteModule = {\n    remoteName?: string;\n    remoteEntry?: string;\n    exposedModule: string;\n}\n\ntype LoadRemoteModule = (optionsOrRemoteName: RemoteModule | string, exposedModule?: string ) => Promise<void>\n\ntype TRemoteModuleLoader = {\n    load: LoadRemoteModule\n}\n\nconst remoteModuleLoaderFactory = (\n    remoteInfoHandler: RemoteInfoHandler,\n    domHandler: DomHandler\n): TRemoteModuleLoader => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModule | string,\n        exposedModule?: string\n    ): RemoteModule =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        \n        throw new NativeFederationError('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) throw new NativeFederationError(`Unknown exposed module ${exposedModule} in remote ${remoteInfo.name}`);\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModule | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NativeFederationError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(domHandler.importModule)\n    }\n\n    return { load }\n}\n\nconst loadRemoteModule: LoadRemoteModule = (\n    remoteNameOrModule: RemoteModule | string,exposedModule?: string,\n    options: Partial<Config> = {}\n) => {\n    const {\n        remoteInfoHandler, \n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const moduleLoader = remoteModuleLoaderFactory(remoteInfoHandler, domHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule, remoteModuleLoaderFactory, LoadRemoteModule, RemoteModule, TRemoteModuleLoader };", "import { type DomHandler } from './dom/dom.handler';\nimport type { ImportMap } from './import-map/import-map.contract';\nimport { type ImportMapHandler } from './import-map/import-map.handler';\nimport { remoteModuleLoaderFactory, type LoadRemoteModule } from './load-remote-module';\nimport type { RemoteInfoHandler } from './remote-entry/remote-info.handler';\nimport { defaultConfig, resolver, type Config } from './resolver';\n\ntype InitFederation = (\n    remotesOrManifestUrl: string | Record<string, string>\n) => Promise<{\n    load: LoadRemoteModule, \n    importMap: ImportMap\n}>\n\ntype FederationInitializer = {\n    init: InitFederation\n}\n\nconst federationInitializerFactory = (\n    remoteInfoHandler: RemoteInfoHandler,\n    importMapHandler: ImportMapHandler,\n    domHandler: DomHandler\n): FederationInitializer => {\n    const remoteModuleLoader = remoteModuleLoaderFactory(remoteInfoHandler, domHandler);\n\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => {\n        return (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    }\n\n    \n    const remoteToImportMap = ([remoteName, remoteEntryUrl]: [string,string]) => {\n        return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n            .then(info => importMapHandler.toImportMap(info, remoteName))\n            .catch(_ => {\n                console.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                return importMapHandler.createEmpty();\n            })\n    }\n\n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise\n            .all(Object.entries(remotes).map(remoteToImportMap))\n            .then(importMapHandler.merge);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(domHandler.createImportMap)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoader.load\n            }))\n    }\n\n    return {init}\n}\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    options: Partial<Config> = {}\n): Promise<{load: LoadRemoteModule, importMap: ImportMap}> => {   \n    const {\n        remoteInfoHandler, \n        importMapHandler,\n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const nfInitializer = federationInitializerFactory( \n        remoteInfoHandler, \n        importMapHandler, \n        domHandler \n    );\n    return nfInitializer.init(remotesOrManifestUrl)\n}\n\nexport { initFederation, federationInitializerFactory, FederationInitializer};", "export {DEFAULT_CACHE} from './default-cache';\n\nexport { CacheEntry, CacheOf, NAMESPACE } from './cache.contract';\nexport { CacheHandler, cacheHandlerFactory, toCache } from './cache.handler';\nexport { createGlobalCache } from './global-cache';", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { toCache } from \"../../lib/cache/cache.handler\";\nimport { type CacheEntryCreator, type CacheOf, NAMESPACE, type NativeFederationProps, type CacheEntry } from \"./../../lib/cache/cache.contract\";\n\nconst sessionStorageCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    const entry = {\n        get(): T {\n            const str = sessionStorage.getItem(`${NAMESPACE}.${key}`) ?? JSON.stringify(_fallback)\n            return JSON.parse(str);\n        },\n        \n        set(value: T): CacheEntry<T> {\n            const clean = typeof value === 'string' ? value : JSON.stringify(value);\n            sessionStorage.setItem(`${NAMESPACE}.${key}`, clean)\n            return entry;\n        },\n        \n        exists(): boolean {\n            return !!sessionStorage.getItem(`${NAMESPACE}.${key}`);\n        }\n    };\n\n    return entry;\n}\n\nconst createSessionStorageCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, sessionStorageCacheEntry)\n}\n\nexport {createSessionStorageCache, sessionStorageCacheEntry};", "import { toCache } from \"../../lib/cache/cache.handler\";\nimport { type CacheEntryCreator, type CacheOf, NAMESPACE, type NativeFederationProps, type CacheEntry } from \"./../../lib/cache/cache.contract\";\n\nconst localStorageCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    const entry = {\n        get(): T {\n            const str = localStorage.getItem(`${NAMESPACE}.${key}`) ?? JSON.stringify(_fallback)\n            return JSON.parse(str);\n        },\n        \n        set(value: T): CacheEntry<T> {\n            const clean = typeof value === 'string' ? value : JSON.stringify(value);\n            localStorage.setItem(`${NAMESPACE}.${key}`, clean)\n            return entry;\n        },\n        \n        exists(): boolean {\n            return !!localStorage.getItem(`${NAMESPACE}.${key}`);\n        }\n    };\n\n    return entry;\n}\n\nconst createLocalStorageCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, localStorageCacheEntry)\n}\n\nexport {createLocalStorageCache, localStorageCacheEntry};", "import { initFederation } from 'vanilla-native-federation';\nimport { createSessionStorageCache } from 'vanilla-native-federation/plugins/storage'\n(() => {\n    const cache = createSessionStorageCache({\n        externals: {},\n        remoteNamesToRemote: {},\n        baseUrlToRemoteNames: {}\n      })\n    initFederation(\"http://localhost:3000/native-federation\", {cache})\n        .then(({load, importMap}) => {\n            console.log(\"importMap: \", importMap);\n            window.dispatchEvent(new CustomEvent(\"mfe-loader-available\", {detail: {load}}));\n        })\n})();"],
  "mappings": "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",
  "names": ["NativeFederationError", "message", "cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "acc", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "createGlobalCache", "cache", "DEFAULT_PROPS", "DEFAULT_CACHE", "domHandlerFactory", "map", "url", "getDir", "parts", "join", "pathA", "pathB", "importMapHandlerFactory", "sharedInfoHandler", "createEmpty", "merge", "maps", "getImports", "remoteInfo", "remoteName", "remote", "getScopedDeps", "remoteInfoHandlerFactory", "cacheHandler", "dependencyHandler", "fromEntryJson", "entryUrl", "r", "cfg", "addRemoteModuleToCache", "v", "remoteEntryUrl", "cachedRemote", "info", "toExternalKey", "shared", "sharedInfoHandlerFactory", "getSharedDepRef", "dep", "mapSharedDeps", "dependencies", "moduleDep", "mapModuleDepsIntoSharedDepsList", "sharedList", "existing", "defaultConfig", "o", "resolver", "remoteInfoHandler", "importMapHandler", "domHandler", "remoteModuleLoaderFactory", "mapToRemoteModule", "optionsOrRemoteName", "exposedModule", "getExposedModuleUrl", "exposed", "e", "remoteNameOrModule", "remoteModule", "federationInitializerFactory", "remoteInfoHandler", "importMapHandler", "domHandler", "remoteModuleLoader", "remoteModuleLoaderFactory", "fetchRemotes", "remotesOrManifestUrl", "r", "remoteToImportMap", "remoteName", "remoteEntryUrl", "info", "_", "createImportMapFromRemotes", "remotes", "importMap", "initFederation", "options", "resolver", "defaultConfig", "cache_exports", "__export", "DEFAULT_CACHE", "NAMESPACE", "cacheHandlerFactory", "createGlobalCache", "toCache", "toCache", "props", "cacheEntryCreator", "acc", "key", "value", "NAMESPACE", "sessionStorageCacheEntry", "_fallback", "entry", "str", "clean", "createSessionStorageCache", "cache", "cache", "createSessionStorageCache", "initFederation", "load", "importMap"]
}
