{
  "version": 3,
  "sources": ["../node_modules/src/lib/native-federation.error.ts", "../node_modules/src/plugins/discovery/discovery.error.ts", "../node_modules/src/lib/utils/version.ts", "../node_modules/src/plugins/discovery/discovery.handler.ts", "../node_modules/src/plugins/discovery/remote-module.handler.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/dom/dom.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/remote-entry/remote-info.handler.ts", "../node_modules/src/lib/remote-entry/shared-info.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/plugins/discovery/resolver.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/plugins/discovery/init-federation-with-discovery.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/plugins/storage/session-cache.ts", "../node_modules/src/plugins/storage/localstorage-cache.ts", "../node_modules/src/lib/native-federation.error.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/dom/dom.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/remote-entry/remote-info.handler.ts", "../node_modules/src/lib/remote-entry/shared-info.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/lib/cache/index.ts", "../src/loader-with-discovery.js"],
  "sourcesContent": ["class NativeFederationError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NativeFederationError}", "import { NativeFederationError } from \"../../lib/native-federation.error\";\n\nclass NFDiscoveryError extends NativeFederationError {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFDiscoveryError\"; \n    }\n}\n\nexport {NFDiscoveryError}", "\nconst compareVersions = (v1: string, v2: string): number => {\n    try{\n        const v1Parts = v1.split('.');\n        const v2Parts = v2.split('.');\n    \n        for (let i = 0; i < Math.min(v1Parts.length, v2Parts.length); i++) {\n            if (Number(v1Parts[i]) > Number(v2Parts[i])) return 1;\n            if (Number(v1Parts[i]) < Number(v2Parts[i])) return -1;\n        }\n    }catch(_) {\n        return v1.localeCompare(v2);\n    }\n\n    return 0;\n};\n\nconst addLatestTag = (remotes: string[]): Record<string, \"latest\"> => {\n    return remotes.reduce((a,b) => ({...a, [b]: \"latest\"}), {});\n}\n\nconst getLatestVersion = (versions: string[]): string|undefined => {\n    return versions.sort(compareVersions)[0];\n}\n\nconst getLatestVersionBefore = (versions: string[], latest: string): string|undefined => {\n    return versions\n        .filter(v => compareVersions(v, latest) < 0)\n        .sort(compareVersions)[0];\n}\n\n\nexport {compareVersions, addLatestTag, getLatestVersion, getLatestVersionBefore};", "import type { AvailableRemoteModules, DiscoveryProps, MfeDiscoveryManifest, RemoteModuleConfigs, CacheResolveOptions, RemoteModuleMeta } from \"./discovery.contract\";\nimport { NFDiscoveryError } from \"./discovery.error\";\nimport type { CacheOf } from \"../../lib/cache/cache.contract\";\nimport type { CacheHandler } from \"../../lib/cache/cache.handler\";\nimport { getLatestVersion, addLatestTag, getLatestVersionBefore } from \"../../lib/utils/version\";\n\ntype DiscoveryHandler = {\n    fetchRemoteConfigs: (discoveryManifestUrl: string, resolveFromCache: CacheResolveOptions) => Promise<RemoteModuleConfigs>\n}\n\nconst discoveryHandlerFactory = (\n    cacheHandler: CacheHandler<CacheOf<DiscoveryProps>>\n): DiscoveryHandler => {\n\n    const getCachedRemoteVersions = (resolveFromCache: CacheResolveOptions): RemoteModuleConfigs|false => {\n        if (resolveFromCache === \"skip-cache\") return false;\n        if (!cacheHandler.entry(\"discovery\").exists()) return false;\n\n        const cache = cacheHandler.fetch(\"discovery\");\n\n        const cachedRemoteConfigs: RemoteModuleConfigs = {};\n\n        if(resolveFromCache === \"all-latest\") resolveFromCache = addLatestTag(Object.keys(cache));\n\n        for (const [remote, reqVersion] of Object.entries(resolveFromCache)) {\n\n            if(!cache[remote] || Object.keys(cache[remote]).length === 0) return false;\n\n            const version = (reqVersion === \"latest\")\n                ? getLatestVersion(Object.keys(cache[remote]))!\n                : reqVersion;\n\n            if(!cache[remote][version]) return false;\n            cachedRemoteConfigs[remote] = cache[remote][version]!\n        }\n\n        return cachedRemoteConfigs;\n    }\n\n    const mapToRequestedVersion = (resolveVersions: Exclude<CacheResolveOptions, \"from-cache\">) => (fetchedRemotes: AvailableRemoteModules): RemoteModuleConfigs => {\n        if(resolveVersions === \"all-latest\" || Object.keys(resolveVersions).length < 1) {\n            resolveVersions = addLatestTag(Object.keys(fetchedRemotes));\n        }\n\n        return Object.entries(resolveVersions).reduce((acc,[remote, version]) => {\n            if(!fetchedRemotes[remote] || fetchedRemotes[remote].length < 1) \n                throw new NFDiscoveryError(`Remote '${remote}' is not available in discovery.`);\n            \n            const versions = Object.values(fetchedRemotes[remote])\n                .reduce(\n                    (acc,m) => ({...acc, [m.metadata.version]: m}), \n                    {} as Record<string, RemoteModuleMeta>\n                );\n\n            if (version === \"latest\") version = getLatestVersion(Object.keys(versions))!\n\n            if(!versions[version]) {\n                console.warn(`Version '${version}' of remote '${remote}' is not available in discovery.`);\n                const fallbackVersion = getLatestVersionBefore(Object.keys(versions), version);\n                if (!fallbackVersion) {\n                    throw new NFDiscoveryError(`Remote '${remote}' has no versions available before '${version}' in discovery.`);\n                }\n\n                console.warn(\"Falling back to \" + fallbackVersion);\n                version = fallbackVersion;\n            }\n\n            return {...acc, [remote]: versions[version]!};\n        }, {} as RemoteModuleConfigs)\n    }\n\n    const updateCachedRemoteConfigs = (newRemoteConfigs: RemoteModuleConfigs) => {\n        cacheHandler.mutate(\"discovery\", cache => {\n            Object.entries(newRemoteConfigs).forEach(([remote, cfg]) => {\n                const version = cfg.metadata.version;\n                if(!cache[remote]) cache[remote] = {};\n                if(!cache[remote][version]) cache[remote][version] = cfg;\n            })\n            return cache;\n        });\n        return newRemoteConfigs;\n    }\n\n\n    const fetchRemoteConfigs = (discoveryManifestUrl: string, resolveFromCache: CacheResolveOptions)\n        : Promise<RemoteModuleConfigs> => {\n            const cachedVersions = getCachedRemoteVersions(resolveFromCache);\n            if (cachedVersions) return Promise.resolve(cachedVersions);\n\n            if(resolveFromCache === \"all-latest\") resolveFromCache = {};\n            return fetch(discoveryManifestUrl)\n                .then(r => r.json() as unknown as MfeDiscoveryManifest)\n                .then(manifest => manifest.microFrontends)\n                .then(mapToRequestedVersion(resolveFromCache))\n                .then(updateCachedRemoteConfigs);\n        }\n    return {fetchRemoteConfigs};\n}\n\nexport {discoveryHandlerFactory, DiscoveryHandler}", "import type { DiscoveryProps, RemoteModuleConfigs, RemoteModuleMeta } from \"./discovery.contract\";\nimport { NFDiscoveryError } from \"./discovery.error\";\nimport type { CacheOf } from \"../../lib/cache/cache.contract\";\nimport type { CacheHandler } from \"../../lib/cache/cache.handler\";\nimport type { RemoteModule } from \"../../lib/load-remote-module\";\nimport { getLatestVersion } from \"../../lib/utils/version\";\n\ntype RemoteModuleHandler = {\n    getIfInitialized: (\n        remoteConfigs: RemoteModuleConfigs, \n        remoteName: string,\n        version?: string\n    ) => RemoteModule\n}\n\nconst remoteModuleHandlerFactory = (\n    cacheHandler: CacheHandler<CacheOf<DiscoveryProps>>,\n): RemoteModuleHandler => {\n    const cache = cacheHandler.entry(\"discovery\");\n\n    const tryGetLatestCachedVersion = (cachedRemote?: Record<string, RemoteModuleMeta>): string|undefined => {\n        return getLatestVersion(Object.keys(cachedRemote ?? {}));\n    }\n\n    const tryGetInitializedVersion = (remoteName: string, remoteConfigs: RemoteModuleConfigs): string|undefined => {\n        return remoteConfigs[remoteName]?.metadata.version;\n    }\n\n    const getIfInitialized = (remoteConfigs: RemoteModuleConfigs, remoteName: string, version?: string): RemoteModule => {\n        const cachedRemote = cache.get()[remoteName];\n        if(!cachedRemote || Object.keys(cachedRemote).length < 1) throw new NFDiscoveryError(`Remote '${remoteName}' is not initialized.`);\n\n        if(!version) version = tryGetInitializedVersion(remoteName, remoteConfigs) ?? tryGetLatestCachedVersion(cachedRemote);\n        if(!version) throw new NFDiscoveryError(`Remote '${remoteName}' contains 0 initialized versions.`);\n\n        const remote = cachedRemote[version]\n        if(!remote) throw new NFDiscoveryError(`Version '${version}' from remote '${remoteName}' is not initialized.`);\n\n        return { \n            remoteName, \n            remoteEntry: remote.extras.nativefederation.remoteEntry,\n            exposedModule: remote.extras.nativefederation.exposedModule\n         };\n        \n    }\n    return { getIfInitialized };\n    \n}\n\nexport { remoteModuleHandlerFactory, RemoteModuleHandler }", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type CacheEntry, type NativeFederationProps, type CacheOf } from \"./cache.contract\";\nimport { toCache } from \"./cache.handler\";\n\ntype GlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as GlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as GlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as GlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): CacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nconst createGlobalCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, globalCacheEntry)\n}\n\nexport {globalCacheEntry, createGlobalCache};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\ntype DomHandler = {\n    createImportMap: (map: ImportMap) => ImportMap,\n    importModule: (url: string) => Promise<any>\n}\n\nconst domHandlerFactory = (): DomHandler => {\n\n    const createImportMap = (map: ImportMap): ImportMap => {\n        document.head.appendChild(\n            Object.assign(document.createElement('script'), {\n                type: 'importmap-shim',\n                innerHTML: JSON.stringify(map),\n            })\n        );\n        return map;\n    }\n\n    const importModule = async <T = any>(url: string): Promise<T> => {\n        return (globalThis as any).importShim(url);\n    }\n\n    return {createImportMap, importModule};\n}\n\nexport {domHandlerFactory, DomHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { ImportMap } from \"./import-map.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { SharedInfoHandler } from \"../remote-entry/shared-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype ImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n    createEmpty: () => ImportMap,\n    merge: (maps: ImportMap[]) => ImportMap\n}\n\nconst importMapHandlerFactory = (sharedInfoHandler: SharedInfoHandler): ImportMapHandler => {\n    \n    const createEmpty = (): ImportMap => ({\n        imports: {},\n        scopes: {}\n    })\n\n    const merge = (maps: ImportMap[]) => {\n        return maps.reduce(\n            (acc: ImportMap, map: ImportMap) => ({\n                imports: { ...acc.imports, ...map.imports },\n                scopes: { ...acc.scopes, ...map.scopes },\n            }),\n            createEmpty()\n        );\n    }\n\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: sharedInfoHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap, createEmpty, merge};\n}\n\nexport {importMapHandlerFactory, ImportMapHandler};", "import type { RemoteInfo } from \"./remote-info.contract\";\nimport type { SharedInfoHandler } from \"./shared-info.handler\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (cacheHandler: CacheHandler<NativeFederationCache>, dependencyHandler: SharedInfoHandler): RemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteInfo)\n            .then(cfg => ({...cfg, baseUrl: _path.getDir(entryUrl)}))\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(\"Must provide valid remoteEntry or remoteName\");\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) return Promise.resolve(cachedRemote);\n        if(!remoteEntryUrl) return Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`);\n\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, RemoteInfoHandler};", "import type { SharedInfo, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationProps, CacheEntry } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedInfo): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype SharedInfoHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst sharedInfoHandlerFactory = (cache: CacheHandler<{\"externals\": CacheEntry<Record<string, string>>}>): SharedInfoHandler => {\n    const getSharedDepRef = (dep: SharedInfo): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, sharedInfoHandlerFactory, SharedInfoHandler};", "import type { CacheExtension, NativeFederationCache } from \"./cache/cache.contract\";\nimport  { cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { DEFAULT_CACHE } from \"./cache/default-cache\";\nimport { domHandlerFactory } from \"./dom/dom.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { remoteInfoHandlerFactory } from \"./remote-entry/remote-info.handler\";\nimport { sharedInfoHandlerFactory } from \"./remote-entry/shared-info.handler\";\n\ntype Config<TCache extends NativeFederationCache = NativeFederationCache> = {\n    cache: TCache\n}\n\nconst defaultConfig = (o: Partial<Config<NativeFederationCache & CacheExtension>>): Config<NativeFederationCache & CacheExtension> => {\n    return {\n        cache: o.cache ?? DEFAULT_CACHE\n    }\n}\n\nconst resolver = <TCache extends NativeFederationCache & CacheExtension>(\n    {cache}: Config<TCache>\n) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    const sharedInfoHandler = sharedInfoHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, sharedInfoHandler);\n    const importMapHandler = importMapHandlerFactory(sharedInfoHandler);\n    const domHandler = domHandlerFactory()\n    return {cacheHandler, sharedInfoHandler, remoteInfoHandler, importMapHandler, domHandler};\n}\n\nexport {resolver, Config, defaultConfig};", "import type { DiscoveryCache, CacheResolveOptions } from \"./discovery.contract\";\nimport { discoveryHandlerFactory } from \"./discovery.handler\";\nimport { remoteModuleHandlerFactory } from \"./remote-module.handler\";\nimport { DEFAULT_CACHE } from \"../../lib/cache\";\nimport type { NativeFederationCache } from \"../../lib/cache/cache.contract\";\nimport { toCache } from \"../../lib/cache/cache.handler\";\nimport { globalCacheEntry } from \"../../lib/cache/global-cache\";\nimport { resolver as baseResolver, type Config } from \"../../lib/resolver\";\n\ntype DiscoveryConfig = Config<NativeFederationCache & DiscoveryCache> & {\n    resolveFromCache: CacheResolveOptions\n};\n\nconst defaultConfig = (o: Partial<DiscoveryConfig>): DiscoveryConfig => {\n    return {\n        cache: o.cache ?? {\n            ...DEFAULT_CACHE, \n            ...toCache({discovery: {}}, globalCacheEntry)\n        },\n        resolveFromCache: o.resolveFromCache ?? \"all-latest\"\n    }\n}\n\nconst resolver = (\n    cfg: DiscoveryConfig\n) => {\n    const { \n        cacheHandler,\n        remoteInfoHandler, \n        domHandler,\n        importMapHandler, \n    } = baseResolver(cfg);\n    const discoveryHandler = discoveryHandlerFactory(cacheHandler);\n    const remoteModuleHandler = remoteModuleHandlerFactory(cacheHandler);\n\n    return {\n        cacheHandler, \n        remoteInfoHandler, \n        importMapHandler, \n        domHandler,\n        discoveryHandler,\n        remoteModuleHandler,\n    };\n}\n\nexport { resolver, defaultConfig, DiscoveryConfig };", "\nimport type { DomHandler } from \"./dom/dom.handler\";\nimport { NativeFederationError } from \"./native-federation.error\";\nimport type { RemoteInfo } from \"./remote-entry/remote-info.contract\";\nimport type { RemoteInfoHandler } from \"./remote-entry/remote-info.handler\";\nimport { defaultConfig, resolver, type Config } from \"./resolver\";\nimport * as _path from \"./utils/path\";\n\ntype RemoteModule = {\n    remoteName?: string;\n    remoteEntry?: string;\n    exposedModule: string;\n}\n\ntype LoadRemoteModule = (optionsOrRemoteName: RemoteModule | string, exposedModule?: string ) => Promise<void>\n\ntype TRemoteModuleLoader = {\n    load: LoadRemoteModule\n}\n\nconst remoteModuleLoaderFactory = (\n    remoteInfoHandler: RemoteInfoHandler,\n    domHandler: DomHandler\n): TRemoteModuleLoader => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModule | string,\n        exposedModule?: string\n    ): RemoteModule =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        \n        throw new NativeFederationError('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) throw new NativeFederationError(`Unknown exposed module ${exposedModule} in remote ${remoteInfo.name}`);\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModule | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NativeFederationError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(domHandler.importModule)\n    }\n\n    return { load }\n}\n\nconst loadRemoteModule: LoadRemoteModule = (\n    remoteNameOrModule: RemoteModule | string,exposedModule?: string,\n    options: Partial<Config> = {}\n) => {\n    const {\n        remoteInfoHandler, \n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const moduleLoader = remoteModuleLoaderFactory(remoteInfoHandler, domHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule, remoteModuleLoaderFactory, LoadRemoteModule, RemoteModule, TRemoteModuleLoader };", "import { type DomHandler } from './dom/dom.handler';\nimport type { ImportMap } from './import-map/import-map.contract';\nimport { type ImportMapHandler } from './import-map/import-map.handler';\nimport { remoteModuleLoaderFactory, type LoadRemoteModule } from './load-remote-module';\nimport type { RemoteInfoHandler } from './remote-entry/remote-info.handler';\nimport { defaultConfig, resolver, type Config } from './resolver';\n\ntype InitFederation = (\n    remotesOrManifestUrl: string | Record<string, string>\n) => Promise<{\n    load: LoadRemoteModule, \n    importMap: ImportMap\n}>\n\ntype FederationInitializer = {\n    init: InitFederation\n}\n\nconst federationInitializerFactory = (\n    remoteInfoHandler: RemoteInfoHandler,\n    importMapHandler: ImportMapHandler,\n    domHandler: DomHandler\n): FederationInitializer => {\n    const remoteModuleLoader = remoteModuleLoaderFactory(remoteInfoHandler, domHandler);\n\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => {\n        return (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    }\n\n    \n    const remoteToImportMap = ([remoteName, remoteEntryUrl]: [string,string]) => {\n        return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n            .then(info => importMapHandler.toImportMap(info, remoteName))\n            .catch(_ => {\n                console.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                return importMapHandler.createEmpty();\n            })\n    }\n\n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise\n            .all(Object.entries(remotes).map(remoteToImportMap))\n            .then(importMapHandler.merge);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(domHandler.createImportMap)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoader.load\n            }))\n    }\n\n    return {init}\n}\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    options: Partial<Config> = {}\n): Promise<{load: LoadRemoteModule, importMap: ImportMap}> => {   \n    const {\n        remoteInfoHandler, \n        importMapHandler,\n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const nfInitializer = federationInitializerFactory( \n        remoteInfoHandler, \n        importMapHandler, \n        domHandler \n    );\n    return nfInitializer.init(remotesOrManifestUrl)\n}\n\nexport { initFederation, federationInitializerFactory, FederationInitializer};", "import type { RemoteModuleConfigs, CacheResolveOptions } from \"./discovery.contract\"\nimport { NFDiscoveryError } from \"./discovery.error\"\nimport type { DiscoveryHandler } from \"./discovery.handler\"\nimport type { RemoteModuleHandler } from \"./remote-module.handler\"\nimport { type DiscoveryConfig, resolver, defaultConfig } from \"./resolver\"\nimport type { ImportMap } from \"../../lib/import-map/import-map.contract\"\nimport { federationInitializerFactory, type FederationInitializer } from \"../../lib/init-federation\"\nimport type { LoadRemoteModule } from \"../../lib/load-remote-module\"\n\ntype InitFederationWithDiscovery = (\n    discoveryManifestUrl: string,\n    resolveFromCache: CacheResolveOptions,\n) => Promise<{\n    load: (remote: string, version?: string) => Promise<any>, \n    discovery: RemoteModuleConfigs, \n    importMap: ImportMap\n}>\n\ntype DiscoveryFederationInitializerFactory = {\n    init: InitFederationWithDiscovery\n}\n\nconst initFederationWithDiscoveryFactory = (\n    discoveryHandler: DiscoveryHandler,\n    remoteModuleHandler: RemoteModuleHandler,\n    federationInitializer: FederationInitializer,\n): DiscoveryFederationInitializerFactory => {\n\n    const getEntryPointUrls = (remotes: RemoteModuleConfigs): Record<string, string> => {    \n        return Object.keys(remotes)\n            .reduce((nfConfig, mfe) => {\n                if(!remotes[mfe]) throw new NFDiscoveryError(`Could not preload remote '${mfe}', not available in discovery.`)\n                return {\n                    ...nfConfig, \n                    [mfe]: remotes[mfe].extras.nativefederation.remoteEntry\n                }\n            }, {})\n    }\n\n    const verifyAndLoadModule = (load: LoadRemoteModule, remoteConfigs: RemoteModuleConfigs) => {\n        return (remote: string, version?: string): Promise<any> => {\n            const remoteModule = remoteModuleHandler.getIfInitialized(remoteConfigs, remote, version);\n            return load(remoteModule); \n        }\n    }\n\n    const init = (\n        discoveryManifestUrl: string,\n        resolveFromCache: CacheResolveOptions,\n     ) => {\n        return discoveryHandler\n            .fetchRemoteConfigs(discoveryManifestUrl, resolveFromCache)\n            .then(remoteConfigs => {\n                const entryPoints = getEntryPointUrls(remoteConfigs);\n\n                return federationInitializer.init(entryPoints)\n                    .then(({load, importMap}) => ({\n                        load: verifyAndLoadModule(load, remoteConfigs), \n                        importMap,\n                        discovery: remoteConfigs\n                    }))\n            })\n    }\n    return {init};\n}\n\nconst initFederationWithDiscovery = (\n    discoveryManifestUrl: string,\n    options: Partial<DiscoveryConfig> = {}\n) => {    \n    const cfg = defaultConfig(options);\n    const {\n        remoteInfoHandler, \n        importMapHandler, \n        domHandler,\n        discoveryHandler,\n        remoteModuleHandler\n    } = resolver(cfg);\n\n    return initFederationWithDiscoveryFactory(\n        discoveryHandler, \n        remoteModuleHandler,\n        federationInitializerFactory(remoteInfoHandler, importMapHandler, domHandler), \n    ).init(discoveryManifestUrl, cfg.resolveFromCache);\n}\n\nexport { initFederationWithDiscovery};", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { toCache } from \"../../lib/cache/cache.handler\";\nimport { type CacheEntryCreator, type CacheOf, NAMESPACE, type NativeFederationProps, type CacheEntry } from \"./../../lib/cache/cache.contract\";\n\nconst sessionStorageCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    const entry = {\n        get(): T {\n            const str = sessionStorage.getItem(`${NAMESPACE}.${key}`) ?? JSON.stringify(_fallback)\n            return JSON.parse(str);\n        },\n        \n        set(value: T): CacheEntry<T> {\n            const clean = typeof value === 'string' ? value : JSON.stringify(value);\n            sessionStorage.setItem(`${NAMESPACE}.${key}`, clean)\n            return entry;\n        },\n        \n        exists(): boolean {\n            return !!sessionStorage.getItem(`${NAMESPACE}.${key}`);\n        }\n    };\n\n    return entry;\n}\n\nconst createSessionStorageCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, sessionStorageCacheEntry)\n}\n\nexport {createSessionStorageCache, sessionStorageCacheEntry};", "import { toCache } from \"../../lib/cache/cache.handler\";\nimport { type CacheEntryCreator, type CacheOf, NAMESPACE, type NativeFederationProps, type CacheEntry } from \"./../../lib/cache/cache.contract\";\n\nconst localStorageCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    const entry = {\n        get(): T {\n            const str = localStorage.getItem(`${NAMESPACE}.${key}`) ?? JSON.stringify(_fallback)\n            return JSON.parse(str);\n        },\n        \n        set(value: T): CacheEntry<T> {\n            const clean = typeof value === 'string' ? value : JSON.stringify(value);\n            localStorage.setItem(`${NAMESPACE}.${key}`, clean)\n            return entry;\n        },\n        \n        exists(): boolean {\n            return !!localStorage.getItem(`${NAMESPACE}.${key}`);\n        }\n    };\n\n    return entry;\n}\n\nconst createLocalStorageCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, localStorageCacheEntry)\n}\n\nexport {createLocalStorageCache, localStorageCacheEntry};", "class NativeFederationError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NativeFederationError}", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ntype CacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> = {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => CacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): CacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): CacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, CacheHandler};", "import type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype CacheEntry<T> = {\n    set: (value: T) => CacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends CacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: CacheEntry<T[K]>;\n};\n\ntype CacheExtension = CacheOf<Record<string, any>>;\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => CacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\nexport {NAMESPACE, CacheEntryValue, CacheEntry, CacheExtension, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type CacheEntry, type NativeFederationProps, type CacheOf } from \"./cache.contract\";\nimport { toCache } from \"./cache.handler\";\n\ntype GlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as GlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as GlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as GlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): CacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nconst createGlobalCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, globalCacheEntry)\n}\n\nexport {globalCacheEntry, createGlobalCache};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\ntype DomHandler = {\n    createImportMap: (map: ImportMap) => ImportMap,\n    importModule: (url: string) => Promise<any>\n}\n\nconst domHandlerFactory = (): DomHandler => {\n\n    const createImportMap = (map: ImportMap): ImportMap => {\n        document.head.appendChild(\n            Object.assign(document.createElement('script'), {\n                type: 'importmap-shim',\n                innerHTML: JSON.stringify(map),\n            })\n        );\n        return map;\n    }\n\n    const importModule = async <T = any>(url: string): Promise<T> => {\n        return (globalThis as any).importShim(url);\n    }\n\n    return {createImportMap, importModule};\n}\n\nexport {domHandlerFactory, DomHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { ImportMap } from \"./import-map.contract\";\nimport type { RemoteInfo } from \"../remote-entry/remote-info.contract\";\nimport type { SharedInfoHandler } from \"../remote-entry/shared-info.handler\";\nimport * as _path from \"../utils/path\";\n\ntype ImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n    createEmpty: () => ImportMap,\n    merge: (maps: ImportMap[]) => ImportMap\n}\n\nconst importMapHandlerFactory = (sharedInfoHandler: SharedInfoHandler): ImportMapHandler => {\n    \n    const createEmpty = (): ImportMap => ({\n        imports: {},\n        scopes: {}\n    })\n\n    const merge = (maps: ImportMap[]) => {\n        return maps.reduce(\n            (acc: ImportMap, map: ImportMap) => ({\n                imports: { ...acc.imports, ...map.imports },\n                scopes: { ...acc.scopes, ...map.scopes },\n            }),\n            createEmpty()\n        );\n    }\n\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: sharedInfoHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap, createEmpty, merge};\n}\n\nexport {importMapHandlerFactory, ImportMapHandler};", "import type { RemoteInfo } from \"./remote-info.contract\";\nimport type { SharedInfoHandler } from \"./shared-info.handler\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\ntype RemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (cacheHandler: CacheHandler<NativeFederationCache>, dependencyHandler: SharedInfoHandler): RemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteInfo)\n            .then(cfg => ({...cfg, baseUrl: _path.getDir(entryUrl)}))\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(\"Must provide valid remoteEntry or remoteName\");\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) return Promise.resolve(cachedRemote);\n        if(!remoteEntryUrl) return Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`);\n\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, RemoteInfoHandler};", "import type { SharedInfo, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationProps, CacheEntry } from \"../cache/cache.contract\";\nimport type { CacheHandler } from \"../cache/cache.handler\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedInfo): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype SharedInfoHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst sharedInfoHandlerFactory = (cache: CacheHandler<{\"externals\": CacheEntry<Record<string, string>>}>): SharedInfoHandler => {\n    const getSharedDepRef = (dep: SharedInfo): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, sharedInfoHandlerFactory, SharedInfoHandler};", "import type { CacheExtension, NativeFederationCache } from \"./cache/cache.contract\";\nimport  { cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { DEFAULT_CACHE } from \"./cache/default-cache\";\nimport { domHandlerFactory } from \"./dom/dom.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { remoteInfoHandlerFactory } from \"./remote-entry/remote-info.handler\";\nimport { sharedInfoHandlerFactory } from \"./remote-entry/shared-info.handler\";\n\ntype Config<TCache extends NativeFederationCache = NativeFederationCache> = {\n    cache: TCache\n}\n\nconst defaultConfig = (o: Partial<Config<NativeFederationCache & CacheExtension>>): Config<NativeFederationCache & CacheExtension> => {\n    return {\n        cache: o.cache ?? DEFAULT_CACHE\n    }\n}\n\nconst resolver = <TCache extends NativeFederationCache & CacheExtension>(\n    {cache}: Config<TCache>\n) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    const sharedInfoHandler = sharedInfoHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, sharedInfoHandler);\n    const importMapHandler = importMapHandlerFactory(sharedInfoHandler);\n    const domHandler = domHandlerFactory()\n    return {cacheHandler, sharedInfoHandler, remoteInfoHandler, importMapHandler, domHandler};\n}\n\nexport {resolver, Config, defaultConfig};", "\nimport type { DomHandler } from \"./dom/dom.handler\";\nimport { NativeFederationError } from \"./native-federation.error\";\nimport type { RemoteInfo } from \"./remote-entry/remote-info.contract\";\nimport type { RemoteInfoHandler } from \"./remote-entry/remote-info.handler\";\nimport { defaultConfig, resolver, type Config } from \"./resolver\";\nimport * as _path from \"./utils/path\";\n\ntype RemoteModule = {\n    remoteName?: string;\n    remoteEntry?: string;\n    exposedModule: string;\n}\n\ntype LoadRemoteModule = (optionsOrRemoteName: RemoteModule | string, exposedModule?: string ) => Promise<void>\n\ntype TRemoteModuleLoader = {\n    load: LoadRemoteModule\n}\n\nconst remoteModuleLoaderFactory = (\n    remoteInfoHandler: RemoteInfoHandler,\n    domHandler: DomHandler\n): TRemoteModuleLoader => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModule | string,\n        exposedModule?: string\n    ): RemoteModule =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        \n        throw new NativeFederationError('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) throw new NativeFederationError(`Unknown exposed module ${exposedModule} in remote ${remoteInfo.name}`);\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModule | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NativeFederationError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(domHandler.importModule)\n    }\n\n    return { load }\n}\n\nconst loadRemoteModule: LoadRemoteModule = (\n    remoteNameOrModule: RemoteModule | string,exposedModule?: string,\n    options: Partial<Config> = {}\n) => {\n    const {\n        remoteInfoHandler, \n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const moduleLoader = remoteModuleLoaderFactory(remoteInfoHandler, domHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule, remoteModuleLoaderFactory, LoadRemoteModule, RemoteModule, TRemoteModuleLoader };", "import { type DomHandler } from './dom/dom.handler';\nimport type { ImportMap } from './import-map/import-map.contract';\nimport { type ImportMapHandler } from './import-map/import-map.handler';\nimport { remoteModuleLoaderFactory, type LoadRemoteModule } from './load-remote-module';\nimport type { RemoteInfoHandler } from './remote-entry/remote-info.handler';\nimport { defaultConfig, resolver, type Config } from './resolver';\n\ntype InitFederation = (\n    remotesOrManifestUrl: string | Record<string, string>\n) => Promise<{\n    load: LoadRemoteModule, \n    importMap: ImportMap\n}>\n\ntype FederationInitializer = {\n    init: InitFederation\n}\n\nconst federationInitializerFactory = (\n    remoteInfoHandler: RemoteInfoHandler,\n    importMapHandler: ImportMapHandler,\n    domHandler: DomHandler\n): FederationInitializer => {\n    const remoteModuleLoader = remoteModuleLoaderFactory(remoteInfoHandler, domHandler);\n\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => {\n        return (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    }\n\n    \n    const remoteToImportMap = ([remoteName, remoteEntryUrl]: [string,string]) => {\n        return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n            .then(info => importMapHandler.toImportMap(info, remoteName))\n            .catch(_ => {\n                console.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                return importMapHandler.createEmpty();\n            })\n    }\n\n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise\n            .all(Object.entries(remotes).map(remoteToImportMap))\n            .then(importMapHandler.merge);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(domHandler.createImportMap)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoader.load\n            }))\n    }\n\n    return {init}\n}\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    options: Partial<Config> = {}\n): Promise<{load: LoadRemoteModule, importMap: ImportMap}> => {   \n    const {\n        remoteInfoHandler, \n        importMapHandler,\n        domHandler\n    } = resolver(defaultConfig(options));\n\n    const nfInitializer = federationInitializerFactory( \n        remoteInfoHandler, \n        importMapHandler, \n        domHandler \n    );\n    return nfInitializer.init(remotesOrManifestUrl)\n}\n\nexport { initFederation, federationInitializerFactory, FederationInitializer};", "export {DEFAULT_CACHE} from './default-cache';\n\nexport { CacheEntry, CacheOf, NAMESPACE } from './cache.contract';\nexport { CacheHandler, cacheHandlerFactory, toCache } from './cache.handler';\nexport { createGlobalCache } from './global-cache';", "import { initFederationWithDiscovery } from 'vanilla-native-federation/plugins/discovery';\nimport { createSessionStorageCache } from 'vanilla-native-federation/plugins/storage';\nimport { cache } from 'vanilla-native-federation';\n\n(() => {\n    const customCache = {\n        ...cache.DEFAULT_CACHE,\n        ...createSessionStorageCache({\n            discovery: {}\n        })\n    }\n\n    initFederationWithDiscovery(\n        \"http://localhost:3000\", \n        { cache: customCache }\n    ).then(({load, discovery, importMap}) => {\n        console.log(\"discovery: \", discovery);\n        console.log(\"importMap: \", importMap);\n        window.dispatchEvent(new CustomEvent(\"mfe-loader-available\", {detail: {load}}));\n    })\n})();\n\n"],
  "mappings": "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",
  "names": ["NativeFederationError", "message", "NFDiscoveryError", "compareVersions", "v1", "v2", "v1Parts", "v2Parts", "addLatestTag", "remotes", "a", "b", "getLatestVersion", "versions", "getLatestVersionBefore", "latest", "v", "discoveryHandlerFactory", "cacheHandler", "getCachedRemoteVersions", "resolveFromCache", "cache", "cachedRemoteConfigs", "remote", "reqVersion", "version", "mapToRequestedVersion", "resolveVersions", "fetchedRemotes", "acc", "m", "fallbackVersion", "updateCachedRemoteConfigs", "newRemoteConfigs", "cfg", "discoveryManifestUrl", "cachedVersions", "r", "manifest", "remoteModuleHandlerFactory", "tryGetLatestCachedVersion", "cachedRemote", "tryGetInitializedVersion", "remoteName", "remoteConfigs", "cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "DEFAULT_PROPS", "DEFAULT_CACHE", "domHandlerFactory", "map", "url", "getDir", "parts", "join", "pathA", "pathB", "importMapHandlerFactory", "sharedInfoHandler", "createEmpty", "merge", "maps", "getImports", "remoteInfo", "getScopedDeps", "remoteInfoHandlerFactory", "dependencyHandler", "fromEntryJson", "entryUrl", "addRemoteModuleToCache", "remoteEntryUrl", "info", "toExternalKey", "shared", "sharedInfoHandlerFactory", "getSharedDepRef", "dep", "mapSharedDeps", "dependencies", "moduleDep", "mapModuleDepsIntoSharedDepsList", "sharedList", "existing", "resolver", "remoteInfoHandler", "importMapHandler", "domHandler", "defaultConfig", "o", "discoveryHandler", "remoteModuleHandler", "remoteModuleLoaderFactory", "mapToRemoteModule", "optionsOrRemoteName", "exposedModule", "getExposedModuleUrl", "exposed", "e", "remoteNameOrModule", "remoteModule", "federationInitializerFactory", "remoteModuleLoader", "fetchRemotes", "remotesOrManifestUrl", "remoteToImportMap", "_", "createImportMapFromRemotes", "importMap", "initFederationWithDiscoveryFactory", "federationInitializer", "getEntryPointUrls", "nfConfig", "mfe", "verifyAndLoadModule", "load", "entryPoints", "initFederationWithDiscovery", "options", "toCache", "props", "cacheEntryCreator", "acc", "key", "value", "NAMESPACE", "sessionStorageCacheEntry", "_fallback", "entry", "str", "clean", "createSessionStorageCache", "cache", "cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "acc", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "createGlobalCache", "cache", "DEFAULT_PROPS", "DEFAULT_CACHE", "cache_exports", "__export", "DEFAULT_CACHE", "NAMESPACE", "cacheHandlerFactory", "createGlobalCache", "toCache", "customCache", "cache_exports", "createSessionStorageCache", "initFederationWithDiscovery", "load", "discovery", "importMap"]
}
