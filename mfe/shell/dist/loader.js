var H=Object.defineProperty,C=(e,o)=>{for(var n in o)H(e,n,{get:o[n],enumerable:!0})};function v(e){let o=c=>e[c],n=c=>e[c].get();return{fetch:n,mutate:(c,t)=>{let r=t(n(c));return e[c].set(r),v(e)},get:()=>e,entry:o}}var f=(e,o)=>Object.entries(e).reduce((n,[d,l])=>({...n,[d]:o(d,l)}),{}),p="__NATIVE_FEDERATION__",E=(e,o)=>{globalThis[p]||(globalThis[p]={});let n=globalThis[p],d={get(){return n[e]??o},set(l){return n[e]=l,d},exists(){return e in n}};return d},N=e=>f(e,E),R={externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},y=f(R,E),$=()=>({createImportMap:n=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(n)})),n),importModule:async n=>globalThis.importShim(n)}),F=e=>{let o=e.split("/");return o.pop(),o.join("/")},m=(e,o)=>(e=e.startsWith("/")?e.slice(1):e,o=o.endsWith("/")?o.slice(0,-1):o,`${e}/${o}`),w=e=>{let o=()=>({imports:{},scopes:{}}),n=t=>t.reduce((r,a)=>({imports:{...r.imports,...a.imports},scopes:{...r.scopes,...a.scopes}}),o()),d=(t,r)=>t.exposes.reduce((a,s)=>({...a,[m(r,s.key)]:m(t.baseUrl,s.outFileName)}),{}),l=t=>({[t.baseUrl+"/"]:e.mapSharedDeps(t)});return{toImportMap:(t,r)=>(r||(r=t.name),{imports:d(t,r),scopes:l(t)}),createEmpty:o,merge:n}},L=(e,o,n,d,l)=>{let c=(s={})=>typeof s=="string"?fetch(s).then(u=>u.json()):Promise.resolve(s),t=([s,u])=>n.loadRemoteInfo(u,s).then(b=>d.toImportMap(b,s)).catch(b=>(o.warn(`Error loading remoteEntry for ${s} at '${u}', skipping module`),d.createEmpty())),r=s=>Promise.all(Object.entries(s).map(t)).then(d.merge);return{init:(s={})=>c(s).then(r).then(e.createImportMap).then(u=>({importMap:u,load:l.load}))}},h={debug:0,warn:1,error:2},j=(e,o)=>Object.keys(h).filter(d=>isNaN(Number(d))).reduce((d,l)=>({...d,[l]:c=>{h[l]>=h[e]&&o[l](c)}}),{}),S={debug:e=>{},error:e=>{},warn:e=>{}},i=class extends Error{constructor(e){super(e),this.name="NFError"}},D=(e,o,n)=>{let d=t=>fetch(t).then(r=>r.json()).then(r=>({...r,baseUrl:F(t)})),l=(t,r)=>(e.mutate("remoteNamesToRemote",a=>({...a,[r]:t})),e.mutate("baseUrlToRemoteNames",a=>({...a,[t.baseUrl]:r})),o.debug(`Added remote '${r}' to the cache.`),t);return{loadRemoteInfo:(t,r)=>{if(!r&&t&&(r=e.fetch("baseUrlToRemoteNames")[F(t)]),!r)return Promise.reject(new i("Must provide valid remoteEntry or remoteName"));let a=e.fetch("remoteNamesToRemote")[r];return a?(o.debug(`Remote '${a.name}' retrieved from cache.`),Promise.resolve(a)):t?(o.debug(`Fetching '${r}' remoteEntry.json from: `+t),d(t).then(s=>l(s,r??s.name)).then(n.addSharedDepsToCache).catch(s=>(o.error("Failed to load remoteEntry: "+(s?.message??s)),Promise.reject(new i("Failed to load remoteEntry"))))):Promise.reject(new i(`Module not registered, provide a valid remoteEntryUrl for '${r}'`))}}},g=e=>`${e.packageName}@${e.version}`,_=e=>{let o=c=>e.fetch("externals")[g(c)],n=c=>c.shared.reduce((t,r)=>({...t,[r.packageName]:o(r)||m(c.baseUrl,r.outFileName)}),{}),d=c=>t=>c.shared.reduce((r,a)=>(r[g(a)]||(r[g(a)]=m(c.baseUrl,a.outFileName)),r),t);return{mapSharedDeps:n,addSharedDepsToCache:c=>(e.mutate("externals",d(c)),c)}},x=(e,o,n)=>{let d=(t,r)=>{if(typeof t=="string"&&r)return{remoteName:t,exposedModule:r};if(typeof t=="object"&&!r)return t;throw e.error("Failed to load remote module: exposedModule and/or remoteName not provided"),new i("Failed to load remote module")},l=(t,r)=>{let a=t.exposes.find(s=>s.key===r);if(!a)throw e.error(`Module '${r}'is not exposed in remote '${t.name}'`),new i("Failed to load remote module");return m(t.baseUrl,a.outFileName)};return{load:(t,r)=>{let a=d(t,r);if(e.debug(`Loading module ${JSON.stringify(a)}`),!a.remoteName||a.remoteName==="")throw new i("remoteName cannot be empty");return o.loadRemoteInfo(a.remoteEntry,a.remoteName).then(s=>l(s,a.exposedModule)).then(s=>(e.debug("Importing module: "+s),s)).then(n.importModule)}}},P=e=>({cache:e.cache??y,logger:e.logger??S,logLevel:e.logLevel??"error"}),I=({cache:e,logger:o,logLevel:n})=>{let d=$(),l=v(e),c=j(n,o),t=_(l),r=D(l,c,t),a=w(t),s=x(c,r,d),u=L(d,c,r,a,s);return{domHandler:d,cacheHandler:l,logHandler:c,sharedInfoHandler:t,remoteInfoHandler:r,importMapHandler:a,remoteModuleHandler:s,initFederationHandler:u}},M=(e={},o={})=>{let{initFederationHandler:n}=I(P(o));return n.init(e)};var A={};C(A,{DEFAULT_CACHE:()=>y,NAMESPACE:()=>p,cacheHandlerFactory:()=>v,createGlobalCache:()=>N,toCache:()=>f});var T={debug:e=>console.log(`[DEBUG]: ${e}`),error:e=>console.error(`[NF]: ${e}`),warn:e=>console.warn(`[NF]: ${e}`)};var J=(e,o="error")=>M(e,{logLevel:o,logger:T});export{J as initMicroFrontends};
//# sourceMappingURL=loader.js.map
