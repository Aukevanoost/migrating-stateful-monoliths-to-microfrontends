var O=Object.defineProperty,P=(e,r)=>{for(var n in r)O(e,n,{get:r[n],enumerable:!0})};function w(e){let r=i=>e[i],n=i=>e[i].get();return{fetch:n,mutate:(i,t)=>{let a=t(n(i));return e[i].set(a),w(e)},get:()=>e,entry:r}}var y=(e,r)=>Object.entries(e).reduce((n,[c,d])=>({...n,[c]:r(c,d)}),{}),g="__NATIVE_FEDERATION__",S=(e,r)=>{globalThis[g]||(globalThis[g]={});let n=globalThis[g],c={get(){return n[e]??r},set(d){return n[e]=d,c},exists(){return e in n}};return c},_=e=>y(e,S),A={externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},V=y(A,S);var U={};P(U,{DEFAULT_CACHE:()=>V,NAMESPACE:()=>g,cacheHandlerFactory:()=>w,createGlobalCache:()=>_,toCache:()=>y});var R={debug:e=>console.log(`[DEBUG]: ${e}`),error:e=>console.error(`[NF]: ${e}`),warn:e=>console.warn(`[NF]: ${e}`)};var h=class extends Error{constructor(e){super(e),this.name="NFError"}},v=class extends h{constructor(e){super(e),this.name="NFDiscoveryError"}},k=(e,r,n)=>{let c=t=>Object.keys(t).reduce((a,s)=>{if(!t[s])throw new v(`Could not preload remote '${s}', not available in discovery.`);return{...a,[s]:t[s].module.remoteEntry}},{}),d=(t,a)=>(s,o)=>{let l=n.getIfInitialized(a,s,o);return t(l)};return{init:(t,a)=>r.fetchDiscoveredRemotes(t,a).then(s=>{let o=c(s);return e.init(o).then(({load:l,importMap:u})=>({load:d(l,s),importMap:u,discovered:s}))})}},$=(e,r)=>{try{let n=e.split("."),c=r.split(".");for(let d=0;d<Math.min(n.length,c.length);d++){if(Number(n[d])>Number(c[d]))return 1;if(Number(n[d])<Number(c[d]))return-1}}catch{return e.localeCompare(r)}return 0},j=e=>e.reduce((r,n)=>({...r,[n]:"latest"}),{}),M=e=>e.sort($)[0],J=(e,r)=>e.filter(n=>$(n,r)<0).sort($)[0],z=e=>{let r=e.entry("discovery"),n=i=>M(Object.keys(i??{})),c=(i,t)=>t[i]?.version;return{getIfInitialized:(i,t,a)=>{let s=r.get()[t];if(!s||Object.keys(s).length<1)throw new v(`Remote '${t}' is not initialized.`);if(a||(a=c(t,i)??n(s)),!a)throw new v(`Remote '${t}' contains 0 initialized versions.`);let o=s[a];if(!o)throw new v(`Version '${a}' from remote '${t}' is not initialized.`);return o.module}}},G=(e,r,n)=>{let c=s=>{if(s==="skip-cache")return r.debug("[discovery] Skipping cached module configs"),!1;if(!e.entry("discovery").exists())return r.debug("[discovery] Discovery cache not found."),!1;let o=e.fetch("discovery"),l={};s==="all-latest"&&(r.debug(`[discovery] Adding 'latest' tag to cached remotes: ["${Object.keys(o).join('", "')}"]`),s=j(Object.keys(o)));for(let[u,m]of Object.entries(s)){if(!o[u]||Object.keys(o[u]).length===0)return r.warn(`[discovery] Remote ${u} does not exist in cache. Omitting cache`),!1;let p=m==="latest"?M(Object.keys(o[u])):m;if(!o[u][p])return r.warn(`[discovery] Version ${p} of ${u} does not exist in cache. Omitting cache`),!1;l[u]=o[u][p]}return l},d=s=>o=>((s==="all-latest"||Object.keys(s).length<1)&&(s=j(Object.keys(o))),Object.entries(s).reduce((l,[u,m])=>{if(!o[u]||typeof o[u]!="object")throw new v(`Remote '${u}' is not available in discovery.`);if(m==="latest"&&(m=M(Object.keys(o[u]))),!o[u][m]){r.warn(`[discovery] Version '${m}' of remote '${u}' is not available in discovery.`);let p=J(Object.keys(o[u]),m);if(!p)throw new v(`Remote '${u}' has no versions available before '${m}' in discovery.`);r.warn(`[discovery] Remote ${u} is falling back to version ${p}`),m=p}return{...l,[u]:o[u][m]}},{})),i=s=>(e.mutate("discovery",o=>(Object.entries(s).forEach(([l,u])=>{o[l]||(o[l]={}),o[l][u.version]||(o[l][u.version]=u)}),o)),s),t=s=>o=>{throw r.error(`${s}: ${o?.message??o}`),new v("[discovery] Could not load remote module configs")};return{fetchDiscoveredRemotes:(s,o)=>{let l=c(o);return l?(r.debug("[discovery] Retrieved remote configs from cache."),Promise.resolve(l)):(r.debug(`[discovery] Fetching discovery from ${s}`),o==="all-latest"&&(o={}),fetch(s).catch(t("Fetching manifest failed")).then(u=>n(u.json())).then(d(o)).catch(t("Mapping manifest failed")).then(i).catch(t("Could not update cache")))}}},W=e=>e;function C(e){let r=i=>e[i],n=i=>e[i].get();return{fetch:n,mutate:(i,t)=>{let a=t(n(i));return e[i].set(a),C(e)},get:()=>e,entry:r}}var H=(e,r)=>Object.entries(e).reduce((n,[c,d])=>({...n,[c]:r(c,d)}),{}),b="__NATIVE_FEDERATION__",I=(e,r)=>{globalThis[b]||(globalThis[b]={});let n=globalThis[b],c={get(){return n[e]??r},set(d){return n[e]=d,c},exists(){return e in n}};return c},q={externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},D=H(q,I),K=()=>({createImportMap:n=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(n)})),n),importModule:async n=>globalThis.importShim(n)}),N=e=>{let r=e.split("/");return r.pop(),r.join("/")},f=(e,r)=>(e=e.startsWith("/")?e.slice(1):e,r=r.endsWith("/")?r.slice(0,-1):r,`${e}/${r}`),Q=e=>{let r=()=>({imports:{},scopes:{}}),n=t=>t.reduce((a,s)=>({imports:{...a.imports,...s.imports},scopes:{...a.scopes,...s.scopes}}),r()),c=(t,a)=>t.exposes.reduce((s,o)=>({...s,[f(a,o.key)]:f(t.baseUrl,o.outFileName)}),{}),d=t=>({[t.baseUrl+"/"]:e.mapSharedDeps(t)});return{toImportMap:(t,a)=>(a||(a=t.name),{imports:c(t,a),scopes:d(t)}),createEmpty:r,merge:n}},X=(e,r,n,c,d)=>{let i=(o={})=>typeof o=="string"?fetch(o).then(l=>l.json()):Promise.resolve(o),t=([o,l])=>n.loadRemoteInfo(l,o).then(u=>c.toImportMap(u,o)).catch(u=>(r.warn(`Error loading remoteEntry for ${o} at '${l}', skipping module`),c.createEmpty())),a=o=>Promise.all(Object.entries(o).map(t)).then(c.merge);return{init:(o={})=>i(o).then(a).then(e.createImportMap).then(l=>({importMap:l,load:d.load}))}},F={debug:0,warn:1,error:2},Y=(e,r)=>Object.keys(F).filter(c=>isNaN(Number(c))).reduce((c,d)=>({...c,[d]:i=>{F[d]>=F[e]&&r[d](i)}}),{}),Z={debug:e=>{},error:e=>{},warn:e=>{}},B=(e,r,n)=>{let c=t=>fetch(t).then(a=>a.json()).then(a=>({...a,baseUrl:N(t)})),d=(t,a)=>(e.mutate("remoteNamesToRemote",s=>({...s,[a]:t})),e.mutate("baseUrlToRemoteNames",s=>({...s,[t.baseUrl]:a})),r.debug(`Added remote '${a}' to the cache.`),t);return{loadRemoteInfo:(t,a)=>{if(!a&&t&&(a=e.fetch("baseUrlToRemoteNames")[N(t)]),!a)return Promise.reject(new h("Must provide valid remoteEntry or remoteName"));let s=e.fetch("remoteNamesToRemote")[a];return s?(r.debug(`Remote '${s.name}' retrieved from cache.`),Promise.resolve(s)):t?(r.debug(`Fetching '${a}' remoteEntry.json from: `+t),c(t).then(o=>d(o,a??o.name)).then(n.addSharedDepsToCache).catch(o=>(r.error("Failed to load remoteEntry: "+(o?.message??o)),Promise.reject(new h("Failed to load remoteEntry"))))):Promise.reject(new h(`Module not registered, provide a valid remoteEntryUrl for '${a}'`))}}},E=e=>`${e.packageName}@${e.version}`,ee=e=>{let r=i=>e.fetch("externals")[E(i)],n=i=>i.shared.reduce((t,a)=>({...t,[a.packageName]:r(a)||f(i.baseUrl,a.outFileName)}),{}),c=i=>t=>i.shared.reduce((a,s)=>(a[E(s)]||(a[E(s)]=f(i.baseUrl,s.outFileName)),a),t);return{mapSharedDeps:n,addSharedDepsToCache:i=>(e.mutate("externals",c(i)),i)}},re=(e,r,n)=>{let c=(t,a)=>{if(typeof t=="string"&&a)return{remoteName:t,exposedModule:a};if(typeof t=="object"&&!a)return t;throw e.error("Failed to load remote module: exposedModule and/or remoteName not provided"),new h("Failed to load remote module")},d=(t,a)=>{let s=t.exposes.find(o=>o.key===a);if(!s)throw e.error(`Module '${a}'is not exposed in remote '${t.name}'`),new h("Failed to load remote module");return f(t.baseUrl,s.outFileName)};return{load:(t,a)=>{let s=c(t,a);if(e.debug(`Loading module ${JSON.stringify(s)}`),!s.remoteName||s.remoteName==="")throw new h("remoteName cannot be empty");return r.loadRemoteInfo(s.remoteEntry,s.remoteName).then(o=>d(o,s.exposedModule)).then(o=>(e.debug("Importing module: "+o),o)).then(n.importModule)}}},te=e=>({cache:e.cache??D,logger:e.logger??Z,logLevel:e.logLevel??"error"}),oe=({cache:e,logger:r,logLevel:n})=>{let c=K(),d=C(e),i=Y(n,r),t=ee(d),a=B(d,i,t),s=Q(t),o=re(i,a,c),l=X(c,i,a,s,o);return{domHandler:c,cacheHandler:d,logHandler:i,sharedInfoHandler:t,remoteInfoHandler:a,importMapHandler:s,remoteModuleHandler:o,initFederationHandler:l}},ne=e=>({...te(e),cache:e.cache??{...D,...H({discovery:{}},I)},resolveFromCache:e.resolveFromCache??"all-latest",discoveryMapper:e.discoveryMapper??W}),ae=e=>{let r=oe(e),n=G(r.cacheHandler,r.logHandler,e.discoveryMapper),c=z(r.cacheHandler),d=k(r.initFederationHandler,n,c);return{...r,discoveryHandler:n,remoteModuleAdapter:c,initFederationAdapter:d}},x=(e,r={})=>{let n=ne(r),{initFederationAdapter:c}=ae(n);return c.init(e,n.resolveFromCache)};var se=(e,r)=>Object.entries(e).reduce((n,[c,d])=>({...n,[c]:r(c,d)}),{}),T="__NATIVE_FEDERATION__",ce=(e,r)=>{let n={get(){let c=sessionStorage.getItem(`${T}.${e}`)??JSON.stringify(r);return JSON.parse(c)},set(c){let d=typeof c=="string"?c:JSON.stringify(c);return sessionStorage.setItem(`${T}.${e}`,d),n},exists(){return!!sessionStorage.getItem(`${T}.${e}`)}};return n},L=e=>se(e,ce);x("http://localhost:3000",{cache:L({externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{},discovery:{}}),logLevel:"debug",logger:R}).then(({load:e,discovered:r,importMap:n})=>{console.log("discovered: ",r),console.log("importMap: ",n),window.dispatchEvent(new CustomEvent("mfe-loader-available",{detail:{load:e}}))});
//# sourceMappingURL=loader-from-discovery.js.map
