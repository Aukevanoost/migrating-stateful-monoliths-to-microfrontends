function h(e){let t=r=>e[r],s=r=>e[r].get();return{fetch:s,mutate:(r,o)=>{let a=o(s(r));return e[r].set(a),h(e)},get:()=>e,entry:t}}var g=(e,t)=>Object.entries(e).reduce((s,[i,n])=>({...s,[i]:t(i,n)}),{}),l="__NATIVE_FEDERATION__",b=(e,t)=>{globalThis[l]||(globalThis[l]={});let s=globalThis[l],i={get(){return s[e]??t},set(n){return s[e]=n,i},exists(){return e in s}};return i},T={externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},E=g(T,b),v=()=>({imports:{},scopes:{}}),m=e=>{let t=e.split("/");return t.pop(),t.join("/")},d=(e,t)=>(e=e.startsWith("/")?e.slice(1):e,t=t.endsWith("/")?t.slice(0,-1):t,`${e}/${t}`),F=e=>{let t=(n,r)=>n.exposes.reduce((o,a)=>({...o,[d(r,a.key)]:d(n.baseUrl,a.outFileName)}),{}),s=n=>({[n.baseUrl+"/"]:e.mapSharedDeps(n)});return{toImportMap:(n,r)=>(r||(r=n.name),{imports:t(n,r),scopes:s(n)})}},M=e=>e.reduce((t,s)=>({imports:{...t.imports,...s.imports},scopes:{...t.scopes,...s.scopes}}),v()),u=class extends Error{constructor(e){super(e),this.name="NFError"}},y=(e,t)=>{let s=r=>fetch(r).then(o=>o.json()).then(o=>({...o,baseUrl:m(r)})),i=(r,o)=>(e.mutate("remoteNamesToRemote",a=>({...a,[o]:r})),e.mutate("baseUrlToRemoteNames",a=>({...a,[r.baseUrl]:o})),r);return{loadRemoteInfo:(r,o)=>{if(!o&&r&&(o=e.fetch("baseUrlToRemoteNames")[m(r)]),!o)return Promise.reject("Must provide valid remoteEntry or remoteName");let a=e.fetch("remoteNamesToRemote")[o];return a?Promise.resolve(a):r?s(r).then(c=>i(c,o??c.name)).then(t.addSharedDepsToCache):Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${o}'`)}}},p=e=>`${e.packageName}@${e.version}`,R=e=>{let t=r=>e.fetch("externals")[p(r)],s=r=>r.shared.reduce((o,a)=>({...o,[a.packageName]:t(a)||d(r.baseUrl,a.outFileName)}),{}),i=r=>o=>r.shared.reduce((a,c)=>(a[p(c)]||(a[p(c)]=d(r.baseUrl,c.outFileName)),a),o);return{mapSharedDeps:s,addSharedDepsToCache:r=>(e.mutate("externals",i(r)),r)}},N=e=>{let t=R(e),s=y(e,t),i=F(t);return{sharedInfoHandler:t,remoteInfoHandler:s,importMapHandler:i}},w=e=>{let t=h(e);return{cacheHandler:t,...N(t)}},I=e=>{let t=(n,r)=>{if(typeof n=="string"&&r)return{remoteName:n,exposedModule:r};if(typeof n=="object"&&!r)return n;throw new u("unexpected arguments: please pass options or a remoteName/exposedModule-pair")},s=(n,r)=>{let o=n.exposes.find(a=>a.key===r);if(!o)throw new u(`Unknown exposed module ${r} in remote ${n.name}`);return d(n.baseUrl,o.outFileName)};return{load:(n,r)=>{let o=t(n,r);if(!o.remoteName||o.remoteName==="")throw new u("remoteName cannot be empty");return e.loadRemoteInfo(o.remoteEntry,o.remoteName).then(a=>s(a,o.exposedModule)).then(a=>globalThis.importShim(a))}}};var S=e=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(e)})),e),C=(e,t)=>{let s=(r={})=>typeof r=="string"?fetch(r).then(o=>o.json()):Promise.resolve(r),i=r=>Promise.all(Object.entries(r).map(([o,a])=>e.loadRemoteInfo(a,o).then(c=>t.toImportMap(c,o)).catch(c=>(console.warn(`Error loading remoteEntry for ${o} at '${a}', skipping module`),v())))).then(M);return{init:(r={})=>s(r).then(i).then(S).then(o=>({importMap:o,load:I(e).load}))}},f=(e={},t={})=>{let{remoteInfoHandler:s,importMapHandler:i}=w(t.cache??E);return C(s,i).init(e)};f("http://localhost:3000/native-federation").then(({load:e,importMap:t})=>{console.log("importMap: ",t),window.dispatchEvent(new CustomEvent("mfe-loader-available",{detail:{load:e}}))});
//# sourceMappingURL=loader.js.map
