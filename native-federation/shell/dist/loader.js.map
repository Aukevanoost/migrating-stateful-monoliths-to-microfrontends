{
  "version": 3,
  "sources": ["../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/index.ts", "../node_modules/src/lib/import-map/create-empty-import-map.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/import-map/merge-import-maps.ts", "../node_modules/src/lib/native-federation-error.ts", "../node_modules/src/lib/dependency/dependency.handler.ts", "../node_modules/src/lib/discovery/discovery.handler.ts", "../node_modules/src/lib/remote-info/remote-info.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/utils/dom.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/lib/discovery/discovery.error.ts", "../node_modules/src/lib/discovery/verify-requested-modules.ts", "../node_modules/src/lib/discovery/init-federation-with-discovery.ts", "../src/loader.js"],
  "sourcesContent": ["import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ninterface TCacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => TCacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): TCacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): TCacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, TCacheHandler};", "import type { RemoteInfo } from \"../remote-info/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype TCacheEntry<T> = {\n    set: (value: T) => TCacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends TCacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: TCacheEntry<T[K]>;\n};\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => TCacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\n\n\nexport {NAMESPACE, CacheEntryValue, TCacheEntry, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type TCacheEntry } from \"./cache.contract\";\n\ntype TGlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as TGlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as TGlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as TGlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): TCacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nexport {globalCacheEntry};", "import type { NativeFederationCache } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache({\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}, globalCacheEntry);\n\nexport {DEFAULT_CACHE};", "import type { ImportMap } from \"./import-map.contract\";\n\nconst createEmptyImportMap = (): ImportMap => ({\n    imports: {},\n    scopes: {}\n})\n\nexport { createEmptyImportMap};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import { createEmptyImportMap } from \"./create-empty-import-map\";\nimport type { ImportMap } from \"./import-map.contract\";\nimport type { TDependencyHandler } from \"../dependency/dependency.handler\";\nimport type { RemoteInfo } from \"../remote-info/remote-info.contract\";\nimport * as _path from \"../utils/path\";\n\ntype TImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n}\n\nconst importMapHandlerFactory = (dependencyHandler: TDependencyHandler) => {\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: dependencyHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap};\n}\n\nexport {createEmptyImportMap, importMapHandlerFactory, TImportMapHandler};", "import { createEmptyImportMap } from \"./create-empty-import-map\";\nimport type { ImportMap } from \"./import-map.contract\";\n\nconst mergeImportMaps = (maps: ImportMap[]) => {\n    return maps.reduce(\n        (acc: ImportMap, map: ImportMap) => ({\n            imports: { ...acc.imports, ...map.imports },\n            scopes: { ...acc.scopes, ...map.scopes },\n        }),\n        createEmptyImportMap()\n    );\n}\n\nexport { mergeImportMaps};", "class NativeFederationError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NativeFederationError}", "import type { SharedConfig } from \"./shared-config\";\nimport type { NativeFederationProps, TCacheEntry } from \"../cache/cache.contract\";\nimport type { TCacheHandler } from \"../cache/cache.handler\";\nimport type { RemoteInfo } from \"../remote-info/remote-info.contract\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedConfig): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype TDependencyHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst dependencyHandlerFactory = (cache: TCacheHandler<{\"externals\": TCacheEntry<Record<string, string>>}>): TDependencyHandler => {\n    const getSharedDepRef = (dep: SharedConfig): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, dependencyHandlerFactory, TDependencyHandler};", "import type { AvailableRemoteModules, DiscoveryProps, MfeDiscoveryManifest } from \"./discovery.contract\";\nimport type { CacheOf } from \"../cache/cache.contract\";\nimport type { TCacheHandler } from \"../cache/cache.handler\";\n\ntype TDiscoveryHandler = {\n    fetchDiscovery: (discoveryManifestUrl: string) => Promise<AvailableRemoteModules>\n}\n\nconst discoveryHandlerFactory = (\n    cacheHandler: TCacheHandler<CacheOf<DiscoveryProps>>\n): TDiscoveryHandler => {\n\n    const addAvailableModulesToCache = (modules: AvailableRemoteModules) => {\n        cacheHandler.entry(\"discovery\").set(modules); \n        return modules; \n    }\n\n    const fetchDiscovery = (discoveryManifestUrl: string)\n        : Promise<AvailableRemoteModules> => {\n        const cachedDiscovery = cacheHandler.entry(\"discovery\")\n\n        if(cachedDiscovery.exists()) \n            return Promise.resolve(cachedDiscovery.get());\n\n\n        return fetch(discoveryManifestUrl)\n            .then(r => r.json() as unknown as MfeDiscoveryManifest)\n            .then(manifest => manifest.microFrontends)\n            .then(addAvailableModulesToCache);\n    }\n    return {fetchDiscovery};\n}\n\nexport {discoveryHandlerFactory, TDiscoveryHandler}", "import type { RemoteEntry, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { TCacheHandler } from \"../cache/cache.handler\";\nimport type { TDependencyHandler } from \"../dependency/dependency.handler\";\nimport * as _path from \"../utils/path\";\n\ntype TRemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (cacheHandler: TCacheHandler<NativeFederationCache>, dependencyHandler: TDependencyHandler): TRemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteEntry)\n            .then(cfg => ({...cfg, baseUrl: _path.getDir(entryUrl)}))\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(\"Must provide valid remoteEntry or remoteName\");\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) return Promise.resolve(cachedRemote);\n        if(!remoteEntryUrl) return Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`);\n\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, TRemoteInfoHandler};", "import type { NativeFederationCache } from \"./cache/cache.contract\";\nimport  { type TCacheHandler, cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { dependencyHandlerFactory } from \"./dependency/dependency.handler\";\nimport type { DiscoveryCache } from \"./discovery/discovery.contract\";\nimport { discoveryHandlerFactory } from \"./discovery/discovery.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { remoteInfoHandlerFactory } from \"./remote-info/remote-info.handler\";\n\nconst resolveNativeFedationHandlers = (cacheHandler: TCacheHandler<NativeFederationCache>) => {\n    const dependencyHandler = dependencyHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, dependencyHandler);\n    const importMapHandler = importMapHandlerFactory(dependencyHandler);\n    return {dependencyHandler, remoteInfoHandler, importMapHandler};\n}\n\nconst resolver = (cache: NativeFederationCache) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    return {\n        cacheHandler, \n        ...resolveNativeFedationHandlers(cacheHandler)\n    };\n}\n\nconst discoveryResolver = (cache: DiscoveryCache & NativeFederationCache) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    const discoveryHandler = discoveryHandlerFactory(cacheHandler);\n\n    return {\n        cacheHandler, \n        discoveryHandler,\n        ...resolveNativeFedationHandlers(cacheHandler)\n    };\n}\n\nexport {resolver, discoveryResolver};", "\nimport { DEFAULT_CACHE } from \"./cache\";\nimport type { NativeFederationCache } from \"./cache/cache.contract\";\nimport { NativeFederationError } from \"./native-federation-error\";\nimport type { RemoteInfo } from \"./remote-info/remote-info.contract\";\nimport type { TRemoteInfoHandler } from \"./remote-info/remote-info.handler\";\nimport { resolver } from \"./resolver\";\nimport * as _dom from \"./utils/dom\";\nimport * as _path from \"./utils/path\";\n\ntype RemoteModule = {\n    remoteName?: string;\n    remoteEntry?: string;\n    exposedModule: string;\n}\n\ntype TLoadRemoteModule = (optionsOrRemoteName: RemoteModule | string, exposedModule?: string ) => Promise<void>\n\ntype TRemoteModuleLoader = {\n    load: TLoadRemoteModule\n}\n\nconst remoteModuleLoaderFactory = (remoteInfoHandler: TRemoteInfoHandler): TRemoteModuleLoader => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModule | string,\n        exposedModule?: string\n    ): RemoteModule =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        \n        throw new NativeFederationError('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) throw new NativeFederationError(`Unknown exposed module ${exposedModule} in remote ${remoteInfo.name}`);\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModule | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NativeFederationError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(url => (globalThis as any).importShim(url))\n    }\n\n    return { load }\n}\n\nconst loadRemoteModule: TLoadRemoteModule = (\n    remoteNameOrModule: RemoteModule | string,exposedModule?: string,\n    o: {cache?: NativeFederationCache} = {}\n) => {\n    const {remoteInfoHandler} = resolver(o.cache ?? DEFAULT_CACHE);\n\n    const moduleLoader = remoteModuleLoaderFactory(remoteInfoHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule, remoteModuleLoaderFactory, TLoadRemoteModule, RemoteModule };", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\nconst appendImportMapToBody = (map: ImportMap): ImportMap => {\n    document.head.appendChild(\n        Object.assign(document.createElement('script'), {\n            type: 'importmap-shim',\n            innerHTML: JSON.stringify(map),\n        })\n    );\n    return map;\n}\n\nexport { appendImportMapToBody };", "import { DEFAULT_CACHE } from './cache';\nimport type { NativeFederationCache } from './cache/cache.contract';\nimport type { ImportMap } from './import-map/import-map.contract';\nimport { createEmptyImportMap, type TImportMapHandler } from './import-map/import-map.handler';\nimport { mergeImportMaps } from './import-map/merge-import-maps';\nimport { remoteModuleLoaderFactory, type TLoadRemoteModule } from './load-remote-module';\nimport type { TRemoteInfoHandler } from './remote-info/remote-info.handler';\nimport { resolver } from './resolver';\nimport * as _dom from './utils/dom';\n\ntype TInitFederation = (\n    remotesOrManifestUrl: string | Record<string, string>\n) => Promise<{load: TLoadRemoteModule, importMap: ImportMap}>\n\ntype TFederationInitializer = {\n    init: TInitFederation\n}\n\nconst federationInitializerFactory = (\n    remoteInfoHandler: TRemoteInfoHandler,\n    importMapHandler: TImportMapHandler\n): TFederationInitializer => {\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => \n        (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    \n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise.all(\n            Object.entries(remotes)\n                .map(([remoteName, remoteEntryUrl]) => {\n                    return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n                        .then(info => importMapHandler.toImportMap(info, remoteName))\n                        .catch(_ => {\n                            console.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                            return createEmptyImportMap();\n                        })\n                })\n        ).then(mergeImportMaps);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(_dom.appendImportMapToBody)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoaderFactory(remoteInfoHandler).load\n            }))\n    }\n\n    return {init}\n}\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    o: {cache?: NativeFederationCache} = {}\n)\n    : Promise<{load: TLoadRemoteModule, importMap: ImportMap}> => {    \n        const {remoteInfoHandler, importMapHandler} = resolver(o.cache ?? DEFAULT_CACHE);\n        \n        const nfInitializer = federationInitializerFactory( remoteInfoHandler, importMapHandler );\n        return nfInitializer.init(remotesOrManifestUrl)\n    }\n\nexport { initFederation, federationInitializerFactory, TFederationInitializer};", "import { NativeFederationError } from \"../native-federation-error\";\n\nclass NFDiscoveryError extends NativeFederationError {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFDiscoveryError\"; \n    }\n}\n\nexport {NFDiscoveryError}", "import type { AvailableRemoteModules } from \"./discovery.contract\";\nimport { NFDiscoveryError } from \"./discovery.error\";\n\nconst verifyRequestedModules = (requested: Record<string, string|\"latest\">) => (availableModules: AvailableRemoteModules): Promise<AvailableRemoteModules> => {\n    Object\n        .entries(requested)\n        .forEach(([mfeName, version]) => {\n            if(!availableModules[mfeName] || availableModules[mfeName].length < 1) \n                Promise.reject(new NFDiscoveryError(`Micro frontend '${mfeName}' not found`))\n            \n            if(version !== \"latest\" && !availableModules[mfeName]!.some(m => m.metadata.version === version)){\n                const availableVersions = availableModules[mfeName]!.map(m => m.metadata.version);\n                Promise.reject(new NFDiscoveryError(`Micro frontend '${mfeName}' version '${version}' not found, available: [${availableVersions.join(', ')}]`))\n            }\n        });\n    return Promise.resolve(availableModules);\n}\n\nexport { verifyRequestedModules};", "import { toCache } from \"../cache/cache.handler\"\nimport { federationInitializerFactory, type TFederationInitializer } from \"../init-federation\"\nimport type { DiscoveryCache, AvailableRemoteModule, AvailableRemoteModules } from \"./discovery.contract\"\nimport { DEFAULT_CACHE } from \"../cache\"\nimport { globalCacheEntry } from \"../cache/global-cache\"\nimport type { ImportMap } from \"../import-map/import-map.contract\"\nimport type { TLoadRemoteModule } from \"../load-remote-module\"\nimport type { TDiscoveryHandler } from \"./discovery.handler\"\nimport { verifyRequestedModules } from \"./verify-requested-modules\"\nimport type { NativeFederationCache } from \"../cache/cache.contract\"\nimport { discoveryResolver } from \"../resolver\"\nimport { NFDiscoveryError } from \"./discovery.error\"\n\ntype TInitFederationWithDiscovery = (\n    discoveryManifestUrl: string,\n    microfrontends: string[]|Record<string,string|\"latest\">\n) => Promise<{load: TLoadRemoteModule, discovery: AvailableRemoteModules, importMap: ImportMap}>\n\ntype DiscoveryFederationInitializerFactory = {\n    init: TInitFederationWithDiscovery\n}\n\nconst initFederationWithDiscoveryFactory = (\n    federationInitializer: TFederationInitializer,\n    discoveryHandler: TDiscoveryHandler,\n): DiscoveryFederationInitializerFactory => {\n    const setVersions = (requested: string[]|Record<string, string|\"latest\">): Record<string, string|\"latest\">  => {\n        if(!Array.isArray(requested)) return requested;\n        return requested.reduce((acc, r) => ({...acc, [r]: \"latest\"}), {});\n    }\n\n    const getEntryPointUrls = (availableModules: AvailableRemoteModules, mfeFilter?: Record<string, string|\"latest\">): Record<string, string> => {\n        if(!mfeFilter) mfeFilter = setVersions(Object.keys(availableModules));\n    \n        return Object.entries(mfeFilter)\n            .map(([mfe, version]) => {\n                const availableModule = availableModules[mfe]?.find(m => version === \"latest\" || version === m.metadata.version);\n                if(!availableModule)\n                    throw new NFDiscoveryError(`Micro frontend '${mfe}' version '${version}' does not exist!`);\n                return [mfe, availableModule] as [string, AvailableRemoteModule];\n            })\n            .reduce((nfConfig, [mfe,cfg]) => ({\n                ...nfConfig, \n                [mfe]: cfg.extras.nativefederation.remoteEntry\n            }), {})\n    }\n\n    const init = (\n        discoveryManifestUrl: string,\n        microfrontends: string[]|Record<string,string|\"latest\"> = []\n     ) => {\n        const requestedMFE = setVersions(microfrontends ?? {});\n    \n        return discoveryHandler.fetchDiscovery(discoveryManifestUrl)\n            .then(verifyRequestedModules(requestedMFE))\n            .then(availableModules => {\n                const entryPoints = getEntryPointUrls(availableModules, requestedMFE);\n                return federationInitializer.init(entryPoints)\n                    .then(federationProps => ({\n                        ...federationProps, \n                        discovery: availableModules\n                    }))\n            })\n    }\n\n    return {init};\n}\n\n\nconst initFederationWithDiscovery = (\n    discoveryManifestUrl: string,\n    microfrontends: string[]|Record<string,string|\"latest\"> = [],\n    o: {cache?: NativeFederationCache & DiscoveryCache} = {}\n): Promise<{load: TLoadRemoteModule, discovery: AvailableRemoteModules, importMap: ImportMap}> => {    \n    const {\n        remoteInfoHandler, \n        importMapHandler, \n        discoveryHandler\n    } = discoveryResolver(o.cache ?? {...DEFAULT_CACHE, ...toCache({discovery: {}}, globalCacheEntry)});\n\n    const nfInitializer = federationInitializerFactory(remoteInfoHandler, importMapHandler);\n    return initFederationWithDiscoveryFactory(nfInitializer, discoveryHandler)\n        .init(discoveryManifestUrl, microfrontends);\n}\n\nexport { initFederationWithDiscovery};", "import { initFederation } from 'vanilla-native-federation';\n\n(() => {\n    initFederation(\"http://localhost:3000/native-federation\")\n        .then(({load, importMap}) => {\n            console.log(\"importMap: \", importMap);\n            window.dispatchEvent(new CustomEvent(\"mfe-loader-available\", {detail: {load}}));\n        })\n})();"],
  "mappings": "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",
  "names": ["cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "acc", "value", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "DEFAULT_CACHE", "createEmptyImportMap", "getDir", "url", "parts", "join", "pathA", "pathB", "importMapHandlerFactory", "dependencyHandler", "getImports", "remoteInfo", "remoteName", "remote", "getScopedDeps", "mergeImportMaps", "maps", "map", "NativeFederationError", "message", "toExternalKey", "shared", "dependencyHandlerFactory", "cache", "getSharedDepRef", "dep", "mapSharedDeps", "dependencies", "moduleDep", "mapModuleDepsIntoSharedDepsList", "sharedList", "existing", "remoteInfoHandlerFactory", "cacheHandler", "dependencyHandler", "fromEntryJson", "entryUrl", "r", "cfg", "getDir", "addRemoteModuleToCache", "remoteInfo", "remoteName", "v", "remoteEntryUrl", "cachedRemote", "info", "resolveNativeFedationHandlers", "dependencyHandlerFactory", "remoteInfoHandler", "importMapHandler", "importMapHandlerFactory", "resolver", "cache", "cacheHandlerFactory", "remoteModuleLoaderFactory", "remoteInfoHandler", "mapToRemoteModule", "optionsOrRemoteName", "exposedModule", "NativeFederationError", "getExposedModuleUrl", "remoteInfo", "exposed", "e", "join", "remoteNameOrModule", "remoteModule", "info", "url", "appendImportMapToBody", "map", "federationInitializerFactory", "remoteInfoHandler", "importMapHandler", "fetchRemotes", "remotesOrManifestUrl", "r", "createImportMapFromRemotes", "remotes", "remoteName", "remoteEntryUrl", "info", "_", "createEmptyImportMap", "mergeImportMaps", "importMap", "remoteModuleLoaderFactory", "initFederation", "o", "resolver", "DEFAULT_CACHE", "initFederation", "load", "importMap"]
}
