var d=class extends Error{constructor(e){super(e),this.name="NFError"}},N=(e,o)=>{try{let s=e.split("."),c=o.split(".");for(let a=0;a<Math.min(s.length,c.length);a++){if(Number(s[a])>Number(s[a]))return 1;if(Number(s[a])<Number(s[a]))return-1}}catch{return e.localeCompare(o)}return 0},y=e=>e.reduce((o,s)=>({...o,[s]:"latest"}),{}),E=e=>e.sort(N)[0],w=e=>{let o=r=>{if(!e.entry("discovery").exists()||r==="fetch")return!1;let t=e.fetch("discovery"),n={};Object.keys(r).length<1&&(r=y(Object.keys(t)));for(let[i,l]of Object.entries(r)){if(!t[i]||Object.keys(t[i]).length===0)return!1;let u=l==="latest"?E(Object.keys(t[i])):l;if(!t[i][u])return!1;n[i]=t[i][u]}return n},s=r=>t=>((r==="fetch"||Object.keys(r).length<1)&&(r=y(Object.keys(t))),Object.entries(r).reduce((n,[i,l])=>{if(!t[i]||t[i].length<1)throw new d(`Remote '${i}' is not available in discovery.`);let u=l==="latest"||l==="fetch"?t[i][0]:t[i].find(h=>h.metadata.version===l);if(!u)throw new d(`Version '${l}' of remote '${i}' is not available in discovery.`);return{...n,[i]:u}},{})),c=r=>(e.mutate("discovery",t=>(Object.entries(r).forEach(([n,i])=>{let l=i.metadata.version;t[n]||(t[n]={}),t[n][l]||(t[n][l]=i)}),t)),r);return{fetchRemoteConfigs:(r,t)=>{let n=o(t);return n?Promise.resolve(n):fetch(r).then(i=>i.json()).then(i=>i.microFrontends).then(s(t)).then(c)}}},m=class extends d{constructor(e){super(e),this.name="NFDiscoveryError"}},I=e=>{let o=e.entry("discovery"),s=r=>E(Object.keys(r??{})),c=(r,t)=>t[r]?.metadata.version;return{getIfInitialized:(r,t,n)=>{let i=o.get()[t];if(!i||Object.keys(i).length<1)throw new m(`Remote '${t}' is not initialized.`);if(n||(n=c(t,r)??s(i)),!n)throw new m(`Remote '${t}' contains 0 initialized versions.`);let l=i[n];if(!l)throw new m(`Version '${n}' from remote '${t}' is not initialized.`);return{remoteName:t,remoteEntry:l.extras.nativefederation.remoteEntry,exposedModule:l.extras.nativefederation.exposedModule}}}};function S(e){let o=r=>e[r],s=r=>e[r].get();return{fetch:s,mutate:(r,t)=>{let n=t(s(r));return e[r].set(n),S(e)},get:()=>e,entry:o}}var $=(e,o)=>Object.entries(e).reduce((s,[c,a])=>({...s,[c]:o(c,a)}),{}),b=e=>{let o=e.split("/");return o.pop(),o.join("/")},p=(e,o)=>(e=e.startsWith("/")?e.slice(1):e,o=o.endsWith("/")?o.slice(0,-1):o,`${e}/${o}`),f=e=>`${e.packageName}@${e.version}`,O=e=>{let o=r=>e.fetch("externals")[f(r)],s=r=>r.shared.reduce((t,n)=>({...t,[n.packageName]:o(n)||p(r.baseUrl,n.outFileName)}),{}),c=r=>t=>r.shared.reduce((n,i)=>(n[f(i)]||(n[f(i)]=p(r.baseUrl,i.outFileName)),n),t);return{mapSharedDeps:s,addSharedDepsToCache:r=>(e.mutate("externals",c(r)),r)}},F=()=>({imports:{},scopes:{}}),x=e=>{let o=(a,r)=>a.exposes.reduce((t,n)=>({...t,[p(r,n.key)]:p(a.baseUrl,n.outFileName)}),{}),s=a=>({[a.baseUrl+"/"]:e.mapSharedDeps(a)});return{toImportMap:(a,r)=>(r||(r=a.name),{imports:o(a,r),scopes:s(a)})}},R=(e,o)=>{let s=r=>fetch(r).then(t=>t.json()).then(t=>({...t,baseUrl:b(r)})),c=(r,t)=>(e.mutate("remoteNamesToRemote",n=>({...n,[t]:r})),e.mutate("baseUrlToRemoteNames",n=>({...n,[r.baseUrl]:t})),r);return{loadRemoteInfo:(r,t)=>{if(!t&&r&&(t=e.fetch("baseUrlToRemoteNames")[b(r)]),!t)return Promise.reject("Must provide valid remoteEntry or remoteName");let n=e.fetch("remoteNamesToRemote")[t];return n?Promise.resolve(n):r?s(r).then(i=>c(i,t??i.name)).then(o.addSharedDepsToCache):Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${t}'`)}}},D=e=>{let o=O(e),s=R(e,o),c=x(o);return{dependencyHandler:o,remoteInfoHandler:s,importMapHandler:c}},P=e=>{let o=S(e),s=w(o),c=I(o);return{cacheHandler:o,discoveryHandler:s,remoteModuleHandler:c,...D(o)}},v="__NATIVE_FEDERATION__",M=(e,o)=>{globalThis[v]||(globalThis[v]={});let s=globalThis[v],c={get(){return s[e]??o},set(a){return s[e]=a,c},exists(){return e in s}};return c},H={externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},V=$(H,M),L=e=>e.reduce((o,s)=>({imports:{...o.imports,...s.imports},scopes:{...o.scopes,...s.scopes}}),F()),U=e=>{let o=(a,r)=>{if(typeof a=="string"&&r)return{remoteName:a,exposedModule:r};if(typeof a=="object"&&!r)return a;throw new d("unexpected arguments: please pass options or a remoteName/exposedModule-pair")},s=(a,r)=>{let t=a.exposes.find(n=>n.key===r);if(!t)throw new d(`Unknown exposed module ${r} in remote ${a.name}`);return p(a.baseUrl,t.outFileName)};return{load:(a,r)=>{let t=o(a,r);if(!t.remoteName||t.remoteName==="")throw new d("remoteName cannot be empty");return e.loadRemoteInfo(t.remoteEntry,t.remoteName).then(n=>s(n,t.exposedModule)).then(n=>globalThis.importShim(n))}}},_=e=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(e)})),e),z=(e,o)=>{let s=(r={})=>typeof r=="string"?fetch(r).then(t=>t.json()):Promise.resolve(r),c=r=>Promise.all(Object.entries(r).map(([t,n])=>e.loadRemoteInfo(n,t).then(i=>o.toImportMap(i,t)).catch(i=>(console.warn(`Error loading remoteEntry for ${t} at '${n}', skipping module`),F())))).then(L);return{init:(r={})=>s(r).then(c).then(_).then(t=>({importMap:t,load:U(e).load}))}},A=(e,o,s)=>{let c=(t,n)=>(n||(n=Object.keys(t)),n.reduce((i,l)=>{if(!t[l])throw new d(`Could not preload remote '${l}', not available in discovery.`);return{...i,[l]:t[l].extras.nativefederation.remoteEntry}},{})),a=(t,n)=>(i,l)=>{let u=s.getIfInitialized(n,i,l);return t(u)};return{init:(t,n,i)=>(n!=="fetch"&&Object.keys(n).length<1&&i&&(n=y(i)),o.fetchRemoteConfigs(t,n).then(l=>{let u=c(l,i);return e.init(u).then(({load:h,importMap:j})=>({load:a(h,l),importMap:j,discovery:l}))}))}},C=(e,o)=>{let{remoteInfoHandler:s,importMapHandler:c,discoveryHandler:a,remoteModuleHandler:r}=P(o.cache??{...V,...$({discovery:{}},M)});return A(z(s,c),a,r).init(e,o.remoteVersions??{},o.initSpecificRemotes)};var J=(e,o)=>Object.entries(e).reduce((s,[c,a])=>({...s,[c]:o(c,a)}),{}),g="__NATIVE_FEDERATION__",k=(e,o)=>{let s={get(){let c=sessionStorage.getItem(`${g}.${e}`)??JSON.stringify(o);return JSON.parse(c)},set(c){let a=typeof c=="string"?c:JSON.stringify(c);return sessionStorage.setItem(`${g}.${e}`,a),s},exists(){return!!sessionStorage.getItem(`${g}.${e}`)}};return s},T=e=>J(e,k);(()=>{let e=T({externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{},discovery:{}});C("http://localhost:3000",{cache:e}).then(({load:o,discovery:s,importMap:c})=>{console.log("discovery: ",s),console.log("importMap: ",c),window.dispatchEvent(new CustomEvent("mfe-loader-available",{detail:{load:o}}))})})();
//# sourceMappingURL=loader-with-discovery.js.map
