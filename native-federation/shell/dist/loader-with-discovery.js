function f(r){let t=e=>r[e],o=e=>r[e].get();return{fetch:o,mutate:(e,n)=>{let s=n(o(e));return r[e].set(s),f(r)},get:()=>r,entry:t}}var g=(r,t)=>Object.entries(r).reduce((o,[i,a])=>({...o,[i]:t(i,a)}),{}),m="__NATIVE_FEDERATION__",E=(r,t)=>{globalThis[m]||(globalThis[m]={});let o=globalThis[m],i={get(){return o[r]??t},set(a){return o[r]=a,i},exists(){return r in o}};return i},M=g({externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},E),F=()=>({imports:{},scopes:{}}),y=r=>{let t=r.split("/");return t.pop(),t.join("/")},u=(r,t)=>(r=r.startsWith("/")?r.slice(1):r,t=t.endsWith("/")?t.slice(0,-1):t,`${r}/${t}`),T=r=>{let t=(a,e)=>a.exposes.reduce((n,s)=>({...n,[u(e,s.key)]:u(a.baseUrl,s.outFileName)}),{}),o=a=>({[a.baseUrl+"/"]:r.mapSharedDeps(a)});return{toImportMap:(a,e)=>(e||(e=a.name),{imports:t(a,e),scopes:o(a)})}},D=r=>r.reduce((t,o)=>({imports:{...t.imports,...o.imports},scopes:{...t.scopes,...o.scopes}}),F()),l=class extends Error{constructor(r){super(r),this.name="NFError"}},v=r=>`${r.packageName}@${r.version}`,j=r=>{let t=e=>r.fetch("externals")[v(e)],o=e=>e.shared.reduce((n,s)=>({...n,[s.packageName]:t(s)||u(e.baseUrl,s.outFileName)}),{}),i=e=>n=>e.shared.reduce((s,c)=>(s[v(c)]||(s[v(c)]=u(e.baseUrl,c.outFileName)),s),n);return{mapSharedDeps:o,addSharedDepsToCache:e=>(r.mutate("externals",i(e)),e)}},R=r=>{let t=i=>(r.entry("discovery").set(i),i);return{fetchDiscovery:i=>{let a=r.entry("discovery");return a.exists()?Promise.resolve(a.get()):fetch(i).then(e=>e.json()).then(e=>e.microFrontends).then(t)}}},w=(r,t)=>{let o=e=>fetch(e).then(n=>n.json()).then(n=>({...n,baseUrl:y(e)})),i=(e,n)=>(r.mutate("remoteNamesToRemote",s=>({...s,[n]:e})),r.mutate("baseUrlToRemoteNames",s=>({...s,[e.baseUrl]:n})),e);return{loadRemoteInfo:(e,n)=>{if(!n&&e&&(n=r.fetch("baseUrlToRemoteNames")[y(e)]),!n)return Promise.reject("Must provide valid remoteEntry or remoteName");let s=r.fetch("remoteNamesToRemote")[n];return s?Promise.resolve(s):e?o(e).then(c=>i(c,n??c.name)).then(t.addSharedDepsToCache):Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${n}'`)}}},x=r=>{let t=j(r),o=w(r,t),i=T(t);return{dependencyHandler:t,remoteInfoHandler:o,importMapHandler:i}};var $=r=>{let t=f(r),o=R(t);return{cacheHandler:t,discoveryHandler:o,...x(t)}},H=r=>{let t=(a,e)=>{if(typeof a=="string"&&e)return{remoteName:a,exposedModule:e};if(typeof a=="object"&&!e)return a;throw new l("unexpected arguments: please pass options or a remoteName/exposedModule-pair")},o=(a,e)=>{let n=a.exposes.find(s=>s.key===e);if(!n)throw new l(`Unknown exposed module ${e} in remote ${a.name}`);return u(a.baseUrl,n.outFileName)};return{load:(a,e)=>{let n=t(a,e);if(!n.remoteName||n.remoteName==="")throw new l("remoteName cannot be empty");return r.loadRemoteInfo(n.remoteEntry,n.remoteName).then(s=>o(s,n.exposedModule)).then(s=>globalThis.importShim(s))}}};var C=r=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(r)})),r),I=(r,t)=>{let o=(e={})=>typeof e=="string"?fetch(e).then(n=>n.json()):Promise.resolve(e),i=e=>Promise.all(Object.entries(e).map(([n,s])=>r.loadRemoteInfo(s,n).then(c=>t.toImportMap(c,n)).catch(c=>(console.warn(`Error loading remoteEntry for ${n} at '${s}', skipping module`),F())))).then(D);return{init:(e={})=>o(e).then(i).then(C).then(n=>({importMap:n,load:H(r).load}))}};var h=class extends l{constructor(r){super(r),this.name="NFDiscoveryError"}},P=r=>t=>(Object.entries(r).forEach(([o,i])=>{if((!t[o]||t[o].length<1)&&Promise.reject(new h(`Micro frontend '${o}' not found`)),i!=="latest"&&!t[o].some(a=>a.metadata.version===i)){let a=t[o].map(e=>e.metadata.version);Promise.reject(new h(`Micro frontend '${o}' version '${i}' not found, available: [${a.join(", ")}]`))}}),Promise.resolve(t)),S=(r,t)=>{let o=e=>Array.isArray(e)?e.reduce((n,s)=>({...n,[s]:"latest"}),{}):e,i=(e,n)=>(n||(n=o(Object.keys(e))),Object.entries(n).map(([s,c])=>{let d=e[s]?.find(p=>c==="latest"||c===p.metadata.version);if(!d)throw new h(`Micro frontend '${s}' version '${c}' does not exist!`);return[s,d]}).reduce((s,[c,d])=>({...s,[c]:d.extras.nativefederation.remoteEntry}),{}));return{init:(e,n=[])=>{let s=o(n??{});return t.fetchDiscovery(e).then(P(s)).then(c=>{let d=i(c,s);return r.init(d).then(p=>({...p,discovery:c}))})}}},b=(r,t=[],o={})=>{let{remoteInfoHandler:i,importMapHandler:a,discoveryHandler:e}=$(o.cache??{...M,...g({discovery:{}},E)}),n=I(i,a);return S(n,e).init(r,t)};b("http://localhost:3000",["explore/recommendations","explore/teasers"]).then(({load:r,discovery:t,importMap:o})=>{console.log("discovery: ",t),console.log("importMap: ",o),window.dispatchEvent(new CustomEvent("mfe-loader-available",{detail:{load:r}}))});
//# sourceMappingURL=loader-with-discovery.js.map
