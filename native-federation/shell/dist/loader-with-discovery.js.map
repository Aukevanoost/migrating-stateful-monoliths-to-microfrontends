{
  "version": 3,
  "sources": ["../node_modules/src/lib/native-federation-error.ts", "../node_modules/src/lib/utils/version.ts", "../node_modules/src/plugins/discovery/discovery.handler.ts", "../node_modules/src/plugins/discovery/discovery.error.ts", "../node_modules/src/plugins/discovery/remote-module.handler.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/utils/path.ts", "../node_modules/src/lib/dependency/dependency.handler.ts", "../node_modules/src/lib/import-map/create-empty-import-map.ts", "../node_modules/src/lib/import-map/import-map.handler.ts", "../node_modules/src/lib/remote-info/remote-info.handler.ts", "../node_modules/src/lib/resolver.ts", "../node_modules/src/plugins/discovery/resolver.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/lib/cache/global-cache.ts", "../node_modules/src/lib/cache/default-cache.ts", "../node_modules/src/lib/import-map/merge-import-maps.ts", "../node_modules/src/lib/load-remote-module.ts", "../node_modules/src/lib/utils/dom.ts", "../node_modules/src/lib/init-federation.ts", "../node_modules/src/plugins/discovery/init-federation-with-discovery.ts", "../node_modules/src/lib/cache/cache.handler.ts", "../node_modules/src/lib/cache/cache.contract.ts", "../node_modules/src/plugins/storage/session-cache.ts", "../node_modules/src/plugins/storage/localstorage-cache.ts", "../src/loader-with-discovery.js"],
  "sourcesContent": ["class NativeFederationError extends Error {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFError\"; \n    }\n}\n\nexport {NativeFederationError}", "\nconst compareVersions = (v1: string, v2: string): number => {\n    try{\n        const v1Parts = v1.split('.');\n        const v2Parts = v2.split('.');\n    \n        for (let i = 0; i < Math.min(v1Parts.length, v2Parts.length); i++) {\n            if (Number(v1Parts[i]) > Number(v1Parts[i])) return 1;\n            if (Number(v1Parts[i]) < Number(v1Parts[i])) return -1;\n        }\n    }catch(_) {\n        return v1.localeCompare(v2);\n    }\n\n    return 0;\n};\n\nconst toLatestVersions = (remotes: string[]): Record<string, \"latest\"> => {\n    return remotes.reduce((a,b) => ({...a, [b]: \"latest\"}), {});\n}\n\nconst getLatestVersion = (versions: string[]): string|undefined => {\n    return versions.sort(compareVersions)[0];\n}\n\nexport {compareVersions, toLatestVersions, getLatestVersion};", "import type { AvailableRemoteModules, DiscoveryProps, MfeDiscoveryManifest, RemoteModuleConfigs } from \"./discovery.contract\";\nimport type { CacheOf } from \"../../lib/cache/cache.contract\";\nimport type { TCacheHandler } from \"../../lib/cache/cache.handler\";\nimport { NativeFederationError } from \"../../lib/native-federation-error\";\nimport { getLatestVersion, toLatestVersions } from \"../../lib/utils/version\";\n\ntype TDiscoveryHandler = {\n    fetchRemoteConfigs: (discoveryManifestUrl: string, specificVersions: Record<string,string|\"latest\">|\"fetch\") => Promise<RemoteModuleConfigs>\n}\n\nconst discoveryHandlerFactory = (\n    cacheHandler: TCacheHandler<CacheOf<DiscoveryProps>>\n): TDiscoveryHandler => {\n\n    const getCachedRemoteVersions = (requested: Record<string,string|\"latest\">|\"fetch\"): RemoteModuleConfigs|false => {\n        if (!cacheHandler.entry(\"discovery\").exists()) return false;\n        if (requested === \"fetch\") return false;\n\n        const cache = cacheHandler.fetch(\"discovery\");\n\n        const cachedRemoteConfigs: RemoteModuleConfigs = {};\n\n        if(Object.keys(requested).length < 1) requested = toLatestVersions(Object.keys(cache));\n        for (const [remote, reqVersion] of Object.entries(requested)) {\n\n            if(!cache[remote] || Object.keys(cache[remote]).length === 0) return false;\n\n            const version = (reqVersion === \"latest\")\n                ? getLatestVersion(Object.keys(cache[remote]))!\n                : reqVersion;\n\n            if(!cache[remote][version]) return false;\n            cachedRemoteConfigs[remote] = cache[remote][version]!\n        }\n\n        return cachedRemoteConfigs;\n    }\n\n    const mapToRequestedVersion = (requested: Record<string,string|\"latest\">|\"fetch\") => (fetchedRemotes: AvailableRemoteModules): RemoteModuleConfigs => {\n        if(requested === \"fetch\" || Object.keys(requested).length < 1) {\n            requested = toLatestVersions(Object.keys(fetchedRemotes));\n        }\n\n        return Object.entries(requested).reduce((acc,[remote, version]) => {\n            if(!fetchedRemotes[remote] || fetchedRemotes[remote].length < 1) \n                throw new NativeFederationError(`Remote '${remote}' is not available in discovery.`);\n            \n            const config = (version === \"latest\" || version === \"fetch\")\n                ? fetchedRemotes[remote][0]\n                : fetchedRemotes[remote].find(v => v.metadata.version === version);\n\n            if(!config) \n                throw new NativeFederationError(`Version '${version}' of remote '${remote}' is not available in discovery.`);\n\n            return {...acc, [remote]: config};\n        }, {} as RemoteModuleConfigs)\n    }\n\n    const updateCachedRemoteConfigs = (newRemoteConfigs: RemoteModuleConfigs) => {\n        cacheHandler.mutate(\"discovery\", cache => {\n            Object.entries(newRemoteConfigs).forEach(([remote, cfg]) => {\n                const version = cfg.metadata.version;\n                if(!cache[remote]) cache[remote] = {};\n                if(!cache[remote][version]) cache[remote][version] = cfg;\n            })\n            return cache;\n        });\n        return newRemoteConfigs;\n    }\n\n\n    const fetchRemoteConfigs = (discoveryManifestUrl: string, requested: Record<string,string|\"latest\">|\"fetch\")\n        : Promise<RemoteModuleConfigs> => {\n            const cachedVersions = getCachedRemoteVersions(requested);\n            if (cachedVersions) {\n                return Promise.resolve(cachedVersions);\n            }\n            \n            return fetch(discoveryManifestUrl)\n                .then(r => r.json() as unknown as MfeDiscoveryManifest)\n                .then(manifest => manifest.microFrontends)\n                .then(mapToRequestedVersion(requested))\n                .then(updateCachedRemoteConfigs);\n        }\n    return {fetchRemoteConfigs};\n}\n\nexport {discoveryHandlerFactory, TDiscoveryHandler}", "import { NativeFederationError } from \"../../lib/native-federation-error\";\n\nclass NFDiscoveryError extends NativeFederationError {\n    constructor(message: string) {\n      super(message); \n      this.name = \"NFDiscoveryError\"; \n    }\n}\n\nexport {NFDiscoveryError}", "import type { DiscoveryProps, RemoteModuleConfigs, RemoteModuleMeta } from \"./discovery.contract\";\nimport { NFDiscoveryError } from \"./discovery.error\";\nimport type { CacheOf } from \"../../lib/cache/cache.contract\";\nimport type { TCacheHandler } from \"../../lib/cache/cache.handler\";\nimport type { RemoteModule } from \"../../lib/load-remote-module\";\nimport { getLatestVersion } from \"../../lib/utils/version\";\n\ntype TRemoteModuleHandler = {\n    getIfInitialized: (\n        remoteConfigs: RemoteModuleConfigs, \n        remoteName: string,\n        version?: string\n    ) => RemoteModule\n}\n\nconst remoteModuleHandlerFactory = (\n    cacheHandler: TCacheHandler<CacheOf<DiscoveryProps>>,\n): TRemoteModuleHandler => {\n    const cache = cacheHandler.entry(\"discovery\");\n\n    const tryGetLatestCachedVersion = (cachedRemote?: Record<string, RemoteModuleMeta>): string|undefined => {\n        return getLatestVersion(Object.keys(cachedRemote ?? {}));\n    }\n\n    const tryGetInitializedVersion = (remoteName: string, remoteConfigs: RemoteModuleConfigs): string|undefined => {\n        return remoteConfigs[remoteName]?.metadata.version;\n    }\n\n    const getIfInitialized = (remoteConfigs: RemoteModuleConfigs, remoteName: string, version?: string): RemoteModule => {\n        const cachedRemote = cache.get()[remoteName];\n        if(!cachedRemote || Object.keys(cachedRemote).length < 1) throw new NFDiscoveryError(`Remote '${remoteName}' is not initialized.`);\n\n        if(!version) version = tryGetInitializedVersion(remoteName, remoteConfigs) ?? tryGetLatestCachedVersion(cachedRemote);\n        if(!version) throw new NFDiscoveryError(`Remote '${remoteName}' contains 0 initialized versions.`);\n\n        const remote = cachedRemote[version]\n        if(!remote) throw new NFDiscoveryError(`Version '${version}' from remote '${remoteName}' is not initialized.`);\n\n        return { \n            remoteName, \n            remoteEntry: remote.extras.nativefederation.remoteEntry,\n            exposedModule: remote.extras.nativefederation.exposedModule\n         };\n        \n    }\n    return { getIfInitialized };\n    \n}\n\nexport { remoteModuleHandlerFactory, TRemoteModuleHandler }", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ninterface TCacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => TCacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): TCacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): TCacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, TCacheHandler};", "const getDir = (url: string): string => {\n    const parts = url.split('/');\n    parts.pop();\n    return parts.join('/');\n}\n\nconst join = (pathA: string, pathB: string): string => {\n    pathA = (pathA.startsWith('/')) ? pathA.slice(1) : pathA;\n    pathB = (pathB.endsWith('/')) ? pathB.slice(0, -1) : pathB;\n    return `${pathA}/${pathB}`;\n}\n\nexport {getDir, join}", "import type { SharedConfig } from \"./shared-config\";\nimport type { NativeFederationProps, TCacheEntry } from \"../cache/cache.contract\";\nimport type { TCacheHandler } from \"../cache/cache.handler\";\nimport type { RemoteInfo } from \"../remote-info/remote-info.contract\";\nimport * as _path from \"../utils/path\";\n\nconst toExternalKey = (shared: SharedConfig): string => {\n    return `${shared.packageName}@${shared.version}`;\n}\n\ntype TDependencyHandler = {\n    mapSharedDeps: (remoteInfo: RemoteInfo) => Record<string, string>,\n    addSharedDepsToCache: (remoteInfo: RemoteInfo) => RemoteInfo\n}\n\nconst dependencyHandlerFactory = (cache: TCacheHandler<{\"externals\": TCacheEntry<Record<string, string>>}>): TDependencyHandler => {\n    const getSharedDepRef = (dep: SharedConfig): string|undefined => {\n        return cache.fetch(\"externals\")[toExternalKey(dep)];\n    }\n\n    const mapSharedDeps = (remoteInfo: RemoteInfo) => {\n        return remoteInfo.shared.reduce((dependencies, moduleDep) => {\n            return {\n                ...dependencies,\n                [moduleDep.packageName]: getSharedDepRef(moduleDep) || _path.join(remoteInfo.baseUrl, moduleDep.outFileName)\n            }\n        }, {});\n    }\n\n    const mapModuleDepsIntoSharedDepsList = (remoteInfo: RemoteInfo) => (sharedList: NativeFederationProps[\"externals\"]) => {\n        return remoteInfo.shared.reduce((existing, dep) => {\n            if(!existing[toExternalKey(dep)]) {\n                existing[toExternalKey(dep)] = _path.join(remoteInfo.baseUrl, dep.outFileName);\n            }\n            return existing;\n        }, sharedList)\n    }\n\n    const addSharedDepsToCache = (remoteInfo: RemoteInfo) => {\n        cache.mutate(\"externals\", mapModuleDepsIntoSharedDepsList(remoteInfo))\n        return remoteInfo;\n    }\n\n    return {mapSharedDeps, addSharedDepsToCache};\n}\n\nexport {toExternalKey, dependencyHandlerFactory, TDependencyHandler};", "import type { ImportMap } from \"./import-map.contract\";\n\nconst createEmptyImportMap = (): ImportMap => ({\n    imports: {},\n    scopes: {}\n})\n\nexport { createEmptyImportMap};", "import { createEmptyImportMap } from \"./create-empty-import-map\";\nimport type { ImportMap } from \"./import-map.contract\";\nimport type { TDependencyHandler } from \"../dependency/dependency.handler\";\nimport type { RemoteInfo } from \"../remote-info/remote-info.contract\";\nimport * as _path from \"../utils/path\";\n\ntype TImportMapHandler = {\n    toImportMap: (remoteInfo: RemoteInfo, remoteName?: string) => ImportMap,\n}\n\nconst importMapHandlerFactory = (dependencyHandler: TDependencyHandler) => {\n    const getImports = (remoteInfo: RemoteInfo, remoteName: string) => {\n        return remoteInfo.exposes.reduce((acc,remote) => ({\n            ...acc, \n            [_path.join(remoteName, remote.key)]: _path.join(remoteInfo.baseUrl, remote.outFileName)\n        }), {});\n    }\n\n    const getScopedDeps = (remoteInfo: RemoteInfo) => {\n        return {[remoteInfo.baseUrl + '/']: dependencyHandler.mapSharedDeps(remoteInfo)}\n    }\n\n    const toImportMap = (remoteInfo: RemoteInfo, remoteName?: string): ImportMap => {\n        if(!remoteName) remoteName = remoteInfo.name as string;\n\n        return { \n            imports: getImports(remoteInfo, remoteName), \n            scopes: getScopedDeps(remoteInfo)\n        };\n    }\n\n    return {toImportMap};\n}\n\nexport {createEmptyImportMap, importMapHandlerFactory, TImportMapHandler};", "import type { RemoteEntry, RemoteInfo } from \"./remote-info.contract\";\nimport type { NativeFederationCache } from \"../cache/cache.contract\";\nimport type { TCacheHandler } from \"../cache/cache.handler\";\nimport type { TDependencyHandler } from \"../dependency/dependency.handler\";\nimport * as _path from \"../utils/path\";\n\ntype TRemoteInfoHandler = {\n    loadRemoteInfo: (remoteEntryUrl?: string, remoteName?: string) => Promise<RemoteInfo>\n}\n\nconst remoteInfoHandlerFactory = (cacheHandler: TCacheHandler<NativeFederationCache>, dependencyHandler: TDependencyHandler): TRemoteInfoHandler => {\n\n    const fromEntryJson = (entryUrl: string): Promise<RemoteInfo> => {\n        return fetch(entryUrl)\n            .then(r => r.json() as unknown as RemoteEntry)\n            .then(cfg => ({...cfg, baseUrl: _path.getDir(entryUrl)}))\n    }\n\n    const addRemoteModuleToCache = (remoteInfo: RemoteInfo, remoteName: string): RemoteInfo => {\n        cacheHandler.mutate(\"remoteNamesToRemote\", v => ({...v, [remoteName]: remoteInfo}));\n        cacheHandler.mutate(\"baseUrlToRemoteNames\", v => ({...v, [remoteInfo.baseUrl]: remoteName}));\n        return remoteInfo;\n    } \n\n    const loadRemoteInfo = (remoteEntryUrl?: string, remoteName?: string): Promise<RemoteInfo> => {\n        if(!remoteName && !!remoteEntryUrl) remoteName = cacheHandler.fetch(\"baseUrlToRemoteNames\")[_path.getDir(remoteEntryUrl)];\n        if(!remoteName) return Promise.reject(\"Must provide valid remoteEntry or remoteName\");\n\n        const cachedRemote = cacheHandler.fetch(\"remoteNamesToRemote\")[remoteName];\n        if (!!cachedRemote) return Promise.resolve(cachedRemote);\n        if(!remoteEntryUrl) return Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${remoteName}'`);\n\n        return fromEntryJson(remoteEntryUrl)\n            .then(info => addRemoteModuleToCache(info, remoteName ?? info.name))\n            .then(dependencyHandler.addSharedDepsToCache)\n    }\n\n    return {loadRemoteInfo};\n}\n\nexport {remoteInfoHandlerFactory, TRemoteInfoHandler};", "import type { NativeFederationCache } from \"./cache/cache.contract\";\nimport  { type TCacheHandler, cacheHandlerFactory } from \"./cache/cache.handler\";\nimport { dependencyHandlerFactory } from \"./dependency/dependency.handler\";\nimport { importMapHandlerFactory } from \"./import-map/import-map.handler\";\nimport { remoteInfoHandlerFactory } from \"./remote-info/remote-info.handler\";\n\nconst resolveNativeFedationHandlers = (cacheHandler: TCacheHandler<NativeFederationCache>) => {\n    const dependencyHandler = dependencyHandlerFactory(cacheHandler);\n    const remoteInfoHandler = remoteInfoHandlerFactory(cacheHandler, dependencyHandler);\n    const importMapHandler = importMapHandlerFactory(dependencyHandler);\n    return {dependencyHandler, remoteInfoHandler, importMapHandler};\n}\n\nconst resolver = (cache: NativeFederationCache) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    return {\n        cacheHandler, \n        ...resolveNativeFedationHandlers(cacheHandler)\n    };\n}\n\n\n\nexport {resolver, resolveNativeFedationHandlers};", "import type { DiscoveryCache } from \"./discovery.contract\";\nimport { discoveryHandlerFactory } from \"./discovery.handler\";\nimport { remoteModuleHandlerFactory } from \"./remote-module.handler\";\nimport type { NativeFederationCache } from \"../../lib/cache/cache.contract\";\nimport { cacheHandlerFactory } from \"../../lib/cache/cache.handler\";\nimport { resolveNativeFedationHandlers } from \"../../lib/resolver\";\n\n\nconst resolver = (cache: DiscoveryCache & NativeFederationCache) => {\n    const cacheHandler = cacheHandlerFactory(cache);\n    const discoveryHandler = discoveryHandlerFactory(cacheHandler);\n    const remoteModuleHandler = remoteModuleHandlerFactory(cacheHandler);\n\n    return {\n        cacheHandler, \n        discoveryHandler,\n        remoteModuleHandler,\n        ...resolveNativeFedationHandlers(cacheHandler)\n    };\n}\n\nexport { resolver };", "import type { RemoteInfo } from \"../remote-info/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype TCacheEntry<T> = {\n    set: (value: T) => TCacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends TCacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: TCacheEntry<T[K]>;\n};\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => TCacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\n\n\nexport {NAMESPACE, CacheEntryValue, TCacheEntry, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { type CacheEntryCreator, NAMESPACE, type TCacheEntry } from \"./cache.contract\";\n\ntype TGlobalCache = {[NAMESPACE]: Record<string, unknown>;};\n\nconst globalCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    if (!(globalThis as unknown as TGlobalCache)[NAMESPACE]) {\n        (globalThis as unknown as TGlobalCache)[NAMESPACE] = {};\n    }\n    const namespace = (globalThis as unknown as TGlobalCache)[NAMESPACE];\n    \n    const entry = {\n        get(): T {\n            return (namespace[key] as T) ?? _fallback;\n        },\n        \n        set(value: T): TCacheEntry<T> {\n            namespace[key] = value;\n            return entry;\n        },\n        \n        exists(): boolean {\n            return key in namespace;\n        }\n    };\n\n    return entry;\n}\n\nexport {globalCacheEntry};", "import type { NativeFederationCache, NativeFederationProps } from './cache.contract';\nimport { toCache } from './cache.handler';\nimport { globalCacheEntry } from './global-cache';\n\nconst DEFAULT_PROPS: NativeFederationProps = {\n    externals: {},\n    remoteNamesToRemote: {},\n    baseUrlToRemoteNames: {}\n}\n\nconst DEFAULT_CACHE: NativeFederationCache = toCache(DEFAULT_PROPS, globalCacheEntry);\n\nexport {DEFAULT_CACHE, DEFAULT_PROPS};", "import { createEmptyImportMap } from \"./create-empty-import-map\";\nimport type { ImportMap } from \"./import-map.contract\";\n\nconst mergeImportMaps = (maps: ImportMap[]) => {\n    return maps.reduce(\n        (acc: ImportMap, map: ImportMap) => ({\n            imports: { ...acc.imports, ...map.imports },\n            scopes: { ...acc.scopes, ...map.scopes },\n        }),\n        createEmptyImportMap()\n    );\n}\n\nexport { mergeImportMaps};", "\nimport { DEFAULT_CACHE } from \"./cache\";\nimport type { NativeFederationCache } from \"./cache/cache.contract\";\nimport { NativeFederationError } from \"./native-federation-error\";\nimport type { RemoteInfo } from \"./remote-info/remote-info.contract\";\nimport type { TRemoteInfoHandler } from \"./remote-info/remote-info.handler\";\nimport { resolver } from \"./resolver\";\nimport * as _dom from \"./utils/dom\";\nimport * as _path from \"./utils/path\";\n\ntype RemoteModule = {\n    remoteName?: string;\n    remoteEntry?: string;\n    exposedModule: string;\n}\n\ntype TLoadRemoteModule = (optionsOrRemoteName: RemoteModule | string, exposedModule?: string ) => Promise<void>\n\ntype TRemoteModuleLoader = {\n    load: TLoadRemoteModule\n}\n\nconst remoteModuleLoaderFactory = (remoteInfoHandler: TRemoteInfoHandler): TRemoteModuleLoader => {\n\n    const mapToRemoteModule = (\n        optionsOrRemoteName: RemoteModule | string,\n        exposedModule?: string\n    ): RemoteModule =>  {\n        if (typeof optionsOrRemoteName === 'string' && exposedModule) {\n            return {\n                remoteName: optionsOrRemoteName,\n                exposedModule,\n            };\n        } else if (typeof optionsOrRemoteName === 'object' && !exposedModule) {\n            return optionsOrRemoteName;\n        }\n        \n        throw new NativeFederationError('unexpected arguments: please pass options or a remoteName/exposedModule-pair');\n    }\n\n    const getExposedModuleUrl = (remoteInfo: RemoteInfo, exposedModule: string): string => {    \n        const exposed = remoteInfo.exposes.find(e => e.key === exposedModule);\n        if (!exposed) throw new NativeFederationError(`Unknown exposed module ${exposedModule} in remote ${remoteInfo.name}`);\n    \n        return _path.join(remoteInfo.baseUrl, exposed.outFileName);\n    }\n\n    const load = (\n        remoteNameOrModule: RemoteModule | string,\n        exposedModule?: string\n    ): Promise<void> => {\n        const remoteModule = mapToRemoteModule(remoteNameOrModule, exposedModule);\n        if(!remoteModule.remoteName || remoteModule.remoteName === \"\") throw new NativeFederationError('remoteName cannot be empty');\n        return remoteInfoHandler\n            .loadRemoteInfo(remoteModule.remoteEntry, remoteModule.remoteName)\n            .then(info => getExposedModuleUrl(info, remoteModule.exposedModule))\n            .then(url => (globalThis as any).importShim(url))\n    }\n\n    return { load }\n}\n\nconst loadRemoteModule: TLoadRemoteModule = (\n    remoteNameOrModule: RemoteModule | string,exposedModule?: string,\n    o: {cache?: NativeFederationCache} = {}\n) => {\n    const {remoteInfoHandler} = resolver(o.cache ?? DEFAULT_CACHE);\n\n    const moduleLoader = remoteModuleLoaderFactory(remoteInfoHandler);\n    return moduleLoader.load(remoteNameOrModule, exposedModule);\n}\n\nexport { loadRemoteModule, remoteModuleLoaderFactory, TLoadRemoteModule, RemoteModule };", "import type { ImportMap } from \"../import-map/import-map.contract\";\n\nconst appendImportMapToBody = (map: ImportMap): ImportMap => {\n    document.head.appendChild(\n        Object.assign(document.createElement('script'), {\n            type: 'importmap-shim',\n            innerHTML: JSON.stringify(map),\n        })\n    );\n    return map;\n}\n\nexport { appendImportMapToBody };", "import { DEFAULT_CACHE } from './cache';\nimport type { NativeFederationCache } from './cache/cache.contract';\nimport type { ImportMap } from './import-map/import-map.contract';\nimport { createEmptyImportMap, type TImportMapHandler } from './import-map/import-map.handler';\nimport { mergeImportMaps } from './import-map/merge-import-maps';\nimport { remoteModuleLoaderFactory, type TLoadRemoteModule } from './load-remote-module';\nimport type { TRemoteInfoHandler } from './remote-info/remote-info.handler';\nimport { resolver } from './resolver';\nimport * as _dom from './utils/dom';\n\ntype TInitFederation = (\n    remotesOrManifestUrl: string | Record<string, string>\n) => Promise<{\n    load: TLoadRemoteModule, \n    importMap: ImportMap\n}>\n\ntype TFederationInitializer = {\n    init: TInitFederation\n}\n\nconst federationInitializerFactory = (\n    remoteInfoHandler: TRemoteInfoHandler,\n    importMapHandler: TImportMapHandler\n): TFederationInitializer => {\n    const fetchRemotes = (remotesOrManifestUrl: string | Record<string, string> = {}): Promise<Record<string, string>> => \n        (typeof remotesOrManifestUrl === 'string')\n            ? fetch(remotesOrManifestUrl).then(r => r.json())\n            : Promise.resolve(remotesOrManifestUrl)\n    \n    const createImportMapFromRemotes = (remotes: Record<string, string>): Promise<ImportMap> => {\n        return Promise.all(\n            Object.entries(remotes)\n                .map(([remoteName, remoteEntryUrl]) => {\n                    return remoteInfoHandler.loadRemoteInfo(remoteEntryUrl, remoteName)\n                        .then(info => importMapHandler.toImportMap(info, remoteName))\n                        .catch(_ => {\n                            console.warn(`Error loading remoteEntry for ${remoteName} at '${remoteEntryUrl}', skipping module`);\n                            return createEmptyImportMap();\n                        })\n                })\n        ).then(mergeImportMaps);\n    }\n\n    const init = (remotesOrManifestUrl: string | Record<string, string> = {}) => {\n        return fetchRemotes(remotesOrManifestUrl)\n            .then(createImportMapFromRemotes)\n            .then(_dom.appendImportMapToBody)\n            .then(importMap => ({\n                importMap,\n                load: remoteModuleLoaderFactory(remoteInfoHandler).load\n            }))\n    }\n\n    return {init}\n}\n\nconst initFederation = (\n    remotesOrManifestUrl: string | Record<string, string> = {},\n    o: {cache?: NativeFederationCache} = {}\n)\n    : Promise<{load: TLoadRemoteModule, importMap: ImportMap}> => {    \n        const {remoteInfoHandler, importMapHandler} = resolver(o.cache ?? DEFAULT_CACHE);\n        \n        const nfInitializer = federationInitializerFactory( remoteInfoHandler, importMapHandler );\n        return nfInitializer.init(remotesOrManifestUrl)\n    }\n\nexport { initFederation, federationInitializerFactory, TFederationInitializer};", "import type { DiscoveryCache, RemoteModuleConfigs } from \"./discovery.contract\"\nimport type { TDiscoveryHandler } from \"./discovery.handler\"\nimport type { TRemoteModuleHandler } from \"./remote-module.handler\"\nimport { resolver } from \"./resolver\"\nimport { DEFAULT_CACHE } from \"../../lib/cache\"\nimport type { NativeFederationCache } from \"../../lib/cache/cache.contract\"\nimport { toCache } from \"../../lib/cache/cache.handler\"\nimport { globalCacheEntry } from \"../../lib/cache/global-cache\"\nimport type { ImportMap } from \"../../lib/import-map/import-map.contract\"\nimport { federationInitializerFactory, type TFederationInitializer } from \"../../lib/init-federation\"\nimport type { TLoadRemoteModule } from \"../../lib/load-remote-module\"\nimport { NativeFederationError } from \"../../lib/native-federation-error\"\nimport { toLatestVersions } from \"../../lib/utils/version\"\n\ntype TInitFederationWithDiscovery = (\n    discoveryManifestUrl: string,\n    remoteVersions: Record<string,string|\"latest\">|\"fetch\",\n    initSpecificRemotes?: string[],\n) => Promise<{\n    load: (remote: string, version?: string) => Promise<any>, \n    discovery: RemoteModuleConfigs, \n    importMap: ImportMap\n}>\n\ntype DiscoveryFederationInitializerFactory = {\n    init: TInitFederationWithDiscovery\n}\n\nconst initFederationWithDiscoveryFactory = (\n    federationInitializer: TFederationInitializer,\n    discoveryHandler: TDiscoveryHandler,\n    remoteModuleHandler: TRemoteModuleHandler\n): DiscoveryFederationInitializerFactory => {\n\n    const getEntryPointUrls = (remotes: RemoteModuleConfigs, preloadRemotes?: string[]): Record<string, string> => {    \n        if(!preloadRemotes) preloadRemotes = Object.keys(remotes);\n\n        return preloadRemotes\n            .reduce((nfConfig, mfe) => {\n                if(!remotes[mfe]) throw new NativeFederationError(`Could not preload remote '${mfe}', not available in discovery.`)\n                return {\n                    ...nfConfig, \n                    [mfe]: remotes[mfe].extras.nativefederation.remoteEntry\n                }\n            }, {})\n    }\n\n    const verifyAndLoadModule = (load: TLoadRemoteModule, remoteConfigs: RemoteModuleConfigs) => {\n        return (remote: string, version?: string): Promise<any> => {\n            const remoteModule = remoteModuleHandler.getIfInitialized(remoteConfigs, remote, version);\n            return load(remoteModule); \n        }\n    }\n\n    const init = (\n        discoveryManifestUrl: string,\n        remoteVersions: Record<string,string|\"latest\">|\"fetch\",\n        initSpecificRemotes?: string[],\n     ) => {    \n\n        if(remoteVersions !== \"fetch\" && Object.keys(remoteVersions).length < 1 && !!initSpecificRemotes) {\n            remoteVersions = toLatestVersions(initSpecificRemotes);\n        }\n        return discoveryHandler\n            .fetchRemoteConfigs(discoveryManifestUrl, remoteVersions)\n            .then(remoteConfigs => {\n                const entryPoints = getEntryPointUrls(remoteConfigs, initSpecificRemotes);\n                \n                return federationInitializer.init(entryPoints)\n                    .then(({load, importMap}) => ({\n                        load: verifyAndLoadModule(load, remoteConfigs), \n                        importMap,\n                        discovery: remoteConfigs\n                    }))\n            })\n    }\n\n    return {init};\n}\n\n\nconst initFederationWithDiscovery = (\n    discoveryManifestUrl: string,\n    o: {\n        initSpecificRemotes?: string[],\n        remoteVersions?: Record<string,string|\"latest\">|\"fetch\",\n        cache?: NativeFederationCache & DiscoveryCache\n    }\n) => {    \n    const {\n        remoteInfoHandler, \n        importMapHandler, \n        discoveryHandler,\n        remoteModuleHandler\n    } = resolver(o.cache ?? {...DEFAULT_CACHE, ...toCache({discovery: {}}, globalCacheEntry)});\n\n    return initFederationWithDiscoveryFactory(\n        federationInitializerFactory(remoteInfoHandler, importMapHandler), \n        discoveryHandler, \n        remoteModuleHandler\n    ).init(discoveryManifestUrl, o.remoteVersions ?? {}, o.initSpecificRemotes);\n}\n\nexport { initFederationWithDiscovery};", "import type { CacheEntryCreator, CacheEntryValue, CacheOf } from \"./cache.contract\";\n\ninterface TCacheHandler<TCache extends CacheOf<Record<keyof TCache, any>>> {\n    fetch: <K extends keyof TCache>(key: K) => CacheEntryValue<TCache[K]>;\n    entry: <K extends keyof TCache>(key: K) => TCache[K];\n    get: () => TCache;\n    mutate: <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ) => TCacheHandler<TCache>;\n}\n\nfunction cacheHandlerFactory<TCache extends CacheOf<Record<keyof TCache, any>>>(\n    _cache: TCache\n): TCacheHandler<TCache> {\n    const entry = <K extends keyof TCache>(key: K): TCache[K] => {\n        return _cache[key];\n    };\n\n    const fetch = <K extends keyof TCache>(key: K): CacheEntryValue<TCache[K]> => {\n        return _cache[key].get();\n    };\n\n    const mutate = <K extends keyof TCache>(\n        key: K,\n        mutateFn: (v: CacheEntryValue<TCache[K]>) => CacheEntryValue<TCache[K]>\n    ): TCacheHandler<TCache> => {\n        const newVal = mutateFn(fetch(key));\n        _cache[key].set(newVal);\n        return cacheHandlerFactory(_cache);\n    };\n\n    const get = (): TCache => _cache;\n\n    return { fetch, mutate, get, entry };\n}\n\nconst toCache = <Tprops extends Record<string, any>>(\n    props: Tprops,\n    cacheEntryCreator: CacheEntryCreator\n): CacheOf<Tprops> => {\n    return Object.entries(props).reduce(\n        (acc, [key, value]) => ({\n            ...acc,\n            [key]: cacheEntryCreator(key, value)\n        }),\n        {} as CacheOf<Tprops>\n    );\n};\n\nexport {toCache, cacheHandlerFactory, TCacheHandler};", "import type { RemoteInfo } from \"../remote-info/remote-info.contract\";\n\nconst NAMESPACE = \"__NATIVE_FEDERATION__\";\n\n/**\n * ENTRIES\n */\ntype TCacheEntry<T> = {\n    set: (value: T) => TCacheEntry<T>;\n    get: () => T;\n    exists: () => boolean;\n};\n\ntype CacheEntryValue<T> = T extends TCacheEntry<infer U> ? U : never;\n\n\ntype CacheOf<T> = {\n    [K in keyof T]: TCacheEntry<T[K]>;\n};\n\ntype CacheEntryCreator = <T>(key: string, initialValue: T) => TCacheEntry<T>;\n\n/**\n * DEFAULT STORED PROPERTIES\n */\ntype NativeFederationProps = {\n    externals: Record<string, string>;\n    remoteNamesToRemote: Record<string, RemoteInfo>;\n    baseUrlToRemoteNames: Record<string, string>;\n}\n\ntype NativeFederationCache = CacheOf<NativeFederationProps>\n\n\n\nexport {NAMESPACE, CacheEntryValue, TCacheEntry, CacheOf, NativeFederationProps, NativeFederationCache, CacheEntryCreator}", "import { toCache } from \"../../lib/cache/cache.handler\";\nimport { type CacheEntryCreator, type CacheOf, NAMESPACE, type NativeFederationProps, type TCacheEntry } from \"./../../lib/cache/cache.contract\";\n\nconst sessionStorageCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    const entry = {\n        get(): T {\n            const str = sessionStorage.getItem(`${NAMESPACE}.${key}`) ?? JSON.stringify(_fallback)\n            return JSON.parse(str);\n        },\n        \n        set(value: T): TCacheEntry<T> {\n            const clean = typeof value === 'string' ? value : JSON.stringify(value);\n            sessionStorage.setItem(`${NAMESPACE}.${key}`, clean)\n            return entry;\n        },\n        \n        exists(): boolean {\n            return !!sessionStorage.getItem(`${NAMESPACE}.${key}`);\n        }\n    };\n\n    return entry;\n}\n\nconst createSessionStorageCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, sessionStorageCacheEntry)\n}\n\nexport {createSessionStorageCache, sessionStorageCacheEntry};", "import { toCache } from \"../../lib/cache/cache.handler\";\nimport { type CacheEntryCreator, type CacheOf, NAMESPACE, type NativeFederationProps, type TCacheEntry } from \"./../../lib/cache/cache.contract\";\n\nconst localStorageCacheEntry: CacheEntryCreator = <T>(key: string, _fallback: T) => {\n    const entry = {\n        get(): T {\n            const str = localStorage.getItem(`${NAMESPACE}.${key}`) ?? JSON.stringify(_fallback)\n            return JSON.parse(str);\n        },\n        \n        set(value: T): TCacheEntry<T> {\n            const clean = typeof value === 'string' ? value : JSON.stringify(value);\n            localStorage.setItem(`${NAMESPACE}.${key}`, clean)\n            return entry;\n        },\n        \n        exists(): boolean {\n            return !!localStorage.getItem(`${NAMESPACE}.${key}`);\n        }\n    };\n\n    return entry;\n}\n\nconst createLocalStorageCache = <TCache extends NativeFederationProps>(cache: TCache): CacheOf<TCache> => {\n    return toCache(cache, localStorageCacheEntry)\n}\n\nexport {createLocalStorageCache, localStorageCacheEntry};", "import { initFederationWithDiscovery } from 'vanilla-native-federation/plugins/discovery';\nimport { createSessionStorageCache } from 'vanilla-native-federation/plugins/storage';\n\n(() => {\n    const customCache = createSessionStorageCache({\n        externals: {},\n        remoteNamesToRemote: {},\n        baseUrlToRemoteNames: {},\n        discovery: {}\n    })\n    initFederationWithDiscovery(\n        \"http://localhost:3000\", \n        { cache: customCache }\n    ).then(({load, discovery, importMap}) => {\n            console.log(\"discovery: \", discovery);\n            console.log(\"importMap: \", importMap);\n            window.dispatchEvent(new CustomEvent(\"mfe-loader-available\", {detail: {load}}));\n        })\n})();"],
  "mappings": "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",
  "names": ["NativeFederationError", "message", "compareVersions", "v1", "v2", "v1Parts", "v2Parts", "i", "toLatestVersions", "remotes", "a", "b", "getLatestVersion", "versions", "discoveryHandlerFactory", "cacheHandler", "getCachedRemoteVersions", "requested", "cache", "cachedRemoteConfigs", "remote", "reqVersion", "version", "mapToRequestedVersion", "fetchedRemotes", "acc", "config", "v", "updateCachedRemoteConfigs", "newRemoteConfigs", "cfg", "discoveryManifestUrl", "cachedVersions", "r", "manifest", "NFDiscoveryError", "remoteModuleHandlerFactory", "tryGetLatestCachedVersion", "cachedRemote", "tryGetInitializedVersion", "remoteName", "remoteConfigs", "cacheHandlerFactory", "_cache", "entry", "key", "fetch", "mutateFn", "newVal", "toCache", "props", "cacheEntryCreator", "value", "getDir", "url", "parts", "join", "pathA", "pathB", "toExternalKey", "shared", "dependencyHandlerFactory", "getSharedDepRef", "dep", "mapSharedDeps", "remoteInfo", "dependencies", "moduleDep", "mapModuleDepsIntoSharedDepsList", "sharedList", "existing", "createEmptyImportMap", "importMapHandlerFactory", "dependencyHandler", "getImports", "getScopedDeps", "remoteInfoHandlerFactory", "fromEntryJson", "entryUrl", "addRemoteModuleToCache", "remoteEntryUrl", "info", "resolveNativeFedationHandlers", "remoteInfoHandler", "importMapHandler", "resolver", "discoveryHandler", "remoteModuleHandler", "NAMESPACE", "globalCacheEntry", "_fallback", "namespace", "DEFAULT_PROPS", "DEFAULT_CACHE", "mergeImportMaps", "maps", "map", "remoteModuleLoaderFactory", "mapToRemoteModule", "optionsOrRemoteName", "exposedModule", "getExposedModuleUrl", "exposed", "e", "remoteNameOrModule", "remoteModule", "appendImportMapToBody", "federationInitializerFactory", "fetchRemotes", "remotesOrManifestUrl", "createImportMapFromRemotes", "_", "importMap", "initFederationWithDiscoveryFactory", "federationInitializer", "getEntryPointUrls", "preloadRemotes", "nfConfig", "mfe", "verifyAndLoadModule", "load", "remoteVersions", "initSpecificRemotes", "entryPoints", "initFederationWithDiscovery", "toCache", "props", "cacheEntryCreator", "acc", "key", "value", "NAMESPACE", "sessionStorageCacheEntry", "_fallback", "entry", "str", "clean", "createSessionStorageCache", "cache", "customCache", "createSessionStorageCache", "initFederationWithDiscovery", "load", "discovery", "importMap"]
}
