function v(e){let t=r=>e[r],a=r=>e[r].get();return{fetch:a,mutate:(r,n)=>{let s=n(a(r));return e[r].set(s),v(e)},get:()=>e,entry:t}}var f=(e,t)=>Object.entries(e).reduce((a,[i,o])=>({...a,[i]:t(i,o)}),{}),u="__NATIVE_FEDERATION__",g=(e,t)=>{globalThis[u]||(globalThis[u]={});let a=globalThis[u],i={get(){return a[e]??t},set(o){return a[e]=o,i},exists(){return e in a}};return i},E=f({externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},g),h=()=>({imports:{},scopes:{}}),m=e=>{let t=e.split("/");return t.pop(),t.join("/")},d=(e,t)=>(e=e.startsWith("/")?e.slice(1):e,t=t.endsWith("/")?t.slice(0,-1):t,`${e}/${t}`),F=e=>{let t=(o,r)=>o.exposes.reduce((n,s)=>({...n,[d(r,s.key)]:d(o.baseUrl,s.outFileName)}),{}),a=o=>({[o.baseUrl+"/"]:e.mapSharedDeps(o)});return{toImportMap:(o,r)=>(r||(r=o.name),{imports:t(o,r),scopes:a(o)})}},b=e=>e.reduce((t,a)=>({imports:{...t.imports,...a.imports},scopes:{...t.scopes,...a.scopes}}),h()),l=class extends Error{constructor(e){super(e),this.name="NFError"}},p=e=>`${e.packageName}@${e.version}`,M=e=>{let t=r=>e.fetch("externals")[p(r)],a=r=>r.shared.reduce((n,s)=>({...n,[s.packageName]:t(s)||d(r.baseUrl,s.outFileName)}),{}),i=r=>n=>r.shared.reduce((s,c)=>(s[p(c)]||(s[p(c)]=d(r.baseUrl,c.outFileName)),s),n);return{mapSharedDeps:a,addSharedDepsToCache:r=>(e.mutate("externals",i(r)),r)}};var T=(e,t)=>{let a=r=>fetch(r).then(n=>n.json()).then(n=>({...n,baseUrl:m(r)})),i=(r,n)=>(e.mutate("remoteNamesToRemote",s=>({...s,[n]:r})),e.mutate("baseUrlToRemoteNames",s=>({...s,[r.baseUrl]:n})),r);return{loadRemoteInfo:(r,n)=>{if(!n&&r&&(n=e.fetch("baseUrlToRemoteNames")[m(r)]),!n)return Promise.reject("Must provide valid remoteEntry or remoteName");let s=e.fetch("remoteNamesToRemote")[n];return s?Promise.resolve(s):r?a(r).then(c=>i(c,n??c.name)).then(t.addSharedDepsToCache):Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${n}'`)}}},D=e=>{let t=M(e),a=T(e,t),i=F(t);return{dependencyHandler:t,remoteInfoHandler:a,importMapHandler:i}},j=e=>{let t=v(e);return{cacheHandler:t,...D(t)}};var R=e=>{let t=(o,r)=>{if(typeof o=="string"&&r)return{remoteName:o,exposedModule:r};if(typeof o=="object"&&!r)return o;throw new l("unexpected arguments: please pass options or a remoteName/exposedModule-pair")},a=(o,r)=>{let n=o.exposes.find(s=>s.key===r);if(!n)throw new l(`Unknown exposed module ${r} in remote ${o.name}`);return d(o.baseUrl,n.outFileName)};return{load:(o,r)=>{let n=t(o,r);if(!n.remoteName||n.remoteName==="")throw new l("remoteName cannot be empty");return e.loadRemoteInfo(n.remoteEntry,n.remoteName).then(s=>a(s,n.exposedModule)).then(s=>globalThis.importShim(s))}}};var w=e=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(e)})),e),$=(e,t)=>{let a=(r={})=>typeof r=="string"?fetch(r).then(n=>n.json()):Promise.resolve(r),i=r=>Promise.all(Object.entries(r).map(([n,s])=>e.loadRemoteInfo(s,n).then(c=>t.toImportMap(c,n)).catch(c=>(console.warn(`Error loading remoteEntry for ${n} at '${s}', skipping module`),h())))).then(b);return{init:(r={})=>a(r).then(i).then(w).then(n=>({importMap:n,load:R(e).load}))}},y=(e={},t={})=>{let{remoteInfoHandler:a,importMapHandler:i}=j(t.cache??E);return $(a,i).init(e)};y("http://localhost:3000/native-federation").then(({load:e,importMap:t})=>{console.log("importMap: ",t),window.dispatchEvent(new CustomEvent("mfe-loader-available",{detail:{load:e}}))});
//# sourceMappingURL=loader.js.map
