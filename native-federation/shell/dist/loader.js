function h(e){let r=t=>e[t],s=t=>e[t].get();return{fetch:s,mutate:(t,o)=>{let a=o(s(t));return e[t].set(a),h(e)},get:()=>e,entry:r}}var g=(e,r)=>Object.entries(e).reduce((s,[i,n])=>({...s,[i]:r(i,n)}),{}),l="__NATIVE_FEDERATION__",b=(e,r)=>{globalThis[l]||(globalThis[l]={});let s=globalThis[l],i={get(){return s[e]??r},set(n){return s[e]=n,i},exists(){return e in s}};return i},T={externals:{},remoteNamesToRemote:{},baseUrlToRemoteNames:{}},E=g(T,b),v=()=>({imports:{},scopes:{}}),m=e=>{let r=e.split("/");return r.pop(),r.join("/")},d=(e,r)=>(e=e.startsWith("/")?e.slice(1):e,r=r.endsWith("/")?r.slice(0,-1):r,`${e}/${r}`),F=e=>{let r=(n,t)=>n.exposes.reduce((o,a)=>({...o,[d(t,a.key)]:d(n.baseUrl,a.outFileName)}),{}),s=n=>({[n.baseUrl+"/"]:e.mapSharedDeps(n)});return{toImportMap:(n,t)=>(t||(t=n.name),{imports:r(n,t),scopes:s(n)})}},M=e=>e.reduce((r,s)=>({imports:{...r.imports,...s.imports},scopes:{...r.scopes,...s.scopes}}),v()),u=class extends Error{constructor(e){super(e),this.name="NFError"}},p=e=>`${e.packageName}@${e.version}`,y=e=>{let r=t=>e.fetch("externals")[p(t)],s=t=>t.shared.reduce((o,a)=>({...o,[a.packageName]:r(a)||d(t.baseUrl,a.outFileName)}),{}),i=t=>o=>t.shared.reduce((a,c)=>(a[p(c)]||(a[p(c)]=d(t.baseUrl,c.outFileName)),a),o);return{mapSharedDeps:s,addSharedDepsToCache:t=>(e.mutate("externals",i(t)),t)}},R=(e,r)=>{let s=t=>fetch(t).then(o=>o.json()).then(o=>({...o,baseUrl:m(t)})),i=(t,o)=>(e.mutate("remoteNamesToRemote",a=>({...a,[o]:t})),e.mutate("baseUrlToRemoteNames",a=>({...a,[t.baseUrl]:o})),t);return{loadRemoteInfo:(t,o)=>{if(!o&&t&&(o=e.fetch("baseUrlToRemoteNames")[m(t)]),!o)return Promise.reject("Must provide valid remoteEntry or remoteName");let a=e.fetch("remoteNamesToRemote")[o];return a?Promise.resolve(a):t?s(t).then(c=>i(c,o??c.name)).then(r.addSharedDepsToCache):Promise.reject(`Module not registered, provide a valid remoteEntryUrl for '${o}'`)}}},N=e=>{let r=y(e),s=R(e,r),i=F(r);return{dependencyHandler:r,remoteInfoHandler:s,importMapHandler:i}},w=e=>{let r=h(e);return{cacheHandler:r,...N(r)}},S=e=>{let r=(n,t)=>{if(typeof n=="string"&&t)return{remoteName:n,exposedModule:t};if(typeof n=="object"&&!t)return n;throw new u("unexpected arguments: please pass options or a remoteName/exposedModule-pair")},s=(n,t)=>{let o=n.exposes.find(a=>a.key===t);if(!o)throw new u(`Unknown exposed module ${t} in remote ${n.name}`);return d(n.baseUrl,o.outFileName)};return{load:(n,t)=>{let o=r(n,t);if(!o.remoteName||o.remoteName==="")throw new u("remoteName cannot be empty");return e.loadRemoteInfo(o.remoteEntry,o.remoteName).then(a=>s(a,o.exposedModule)).then(a=>globalThis.importShim(a))}}};var C=e=>(document.head.appendChild(Object.assign(document.createElement("script"),{type:"importmap-shim",innerHTML:JSON.stringify(e)})),e),D=(e,r)=>{let s=(t={})=>typeof t=="string"?fetch(t).then(o=>o.json()):Promise.resolve(t),i=t=>Promise.all(Object.entries(t).map(([o,a])=>e.loadRemoteInfo(a,o).then(c=>r.toImportMap(c,o)).catch(c=>(console.warn(`Error loading remoteEntry for ${o} at '${a}', skipping module`),v())))).then(M);return{init:(t={})=>s(t).then(i).then(C).then(o=>({importMap:o,load:S(e).load}))}},f=(e={},r={})=>{let{remoteInfoHandler:s,importMapHandler:i}=w(r.cache??E);return D(s,i).init(e)};f("http://localhost:3000/native-federation").then(({load:e,importMap:r})=>{console.log("importMap: ",r),window.dispatchEvent(new CustomEvent("mfe-loader-available",{detail:{load:e}}))});
//# sourceMappingURL=loader.js.map
